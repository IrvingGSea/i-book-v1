{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My MkDocs Site","text":""},{"location":"about/","title":"test for about","text":"<ol> <li>Option one  </li> <li>Option two  </li> <li>Option three  </li> <li>Option four  </li> </ol>"},{"location":"contact/","title":"test for contact","text":""},{"location":"course-description/","title":"test for course description","text":"<p>Generate a Summary</p> <p>Please summarize the following passage using key bullet points.</p>"},{"location":"glossary/","title":"test for glossary","text":""},{"location":"how-we-built-this-site/","title":"test for how we built this site","text":""},{"location":"license/","title":"test for license","text":""},{"location":"references/","title":"test for references","text":""},{"location":"toc/","title":"test for table of content","text":""},{"location":"chapters/","title":"Welcome to My MkDocs Site","text":""},{"location":"chapters/chapter-1/","title":"Chapter 1: Introduction to Microcontrollers &amp; PIC24FJ64GA002","text":""},{"location":"chapters/chapter-1/#section-1-what-is-a-microcontroller","title":"Section 1: What is a Microcontroller?","text":"<p>A microcontroller is a compact, self-contained computer system built onto a single integrated circuit. It includes a CPU (central processing unit), memory, and peripherals, making it well-suited for controlling embedded systems and real-world devices.</p>"},{"location":"chapters/chapter-1/#microcontroller-block-diagram","title":"Microcontroller Block Diagram","text":"<p>This diagram shows the typical internal structure of a microcontroller. The CPU core is supported by built-in memory and several peripheral modules such as timers, communication interfaces, and analog components.</p> <p> </p> <p>Unlike general-purpose computers, microcontrollers are designed for specific tasks, such as reading sensor data, driving motors, or communicating with other digital components. They are commonly used in systems that need low power, high reliability, and consistent timing.</p>"},{"location":"chapters/chapter-1/#key-characteristics","title":"Key Characteristics:","text":"<ul> <li>Small footprint: Microcontrollers are tiny, often used in devices with limited space.</li> <li>Real-time control: They\u2019re designed for deterministic behavior \u2014 ideal for time-sensitive applications.</li> <li>Integrated peripherals: Timers, analog-to-digital converters (ADCs), communication modules (UART, SPI, I2C), and more are built-in.</li> <li>Low power consumption: Designed for efficiency, especially in battery-powered devices.</li> </ul>"},{"location":"chapters/chapter-1/#common-use-cases","title":"Common Use Cases:","text":"<ul> <li>Home automation (e.g., smart thermostats)</li> <li>Robotics and motion control</li> <li>Automotive systems (e.g., airbag control)</li> <li>Industrial sensors and actuators</li> <li>Wearable electronics</li> </ul> <p>Microcontrollers are the backbone of embedded systems \u2014 small, purpose-built devices that power our modern, connected world.</p>"},{"location":"chapters/chapter-1/#common-microcontroller-applications","title":"Common Microcontroller Applications","text":"<p>Microcontrollers are used in thousands of everyday systems, often hidden inside devices that respond to inputs, control outputs, or handle timing and communication.</p> <p>Some common microcontroller-driven systems include:</p> <ul> <li>Home automation \u2013 smart thermostats, lighting systems, appliance control</li> <li>Wearables \u2013 smartwatches, fitness trackers, biometric sensors</li> <li>Automotive systems \u2013 engine control units, airbag deployment, infotainment</li> <li>Industrial automation \u2013 motors, valves, conveyor systems</li> <li>Consumer electronics \u2013 printers, game controllers, TVs, toys</li> <li>Medical devices \u2013 glucose monitors, blood pressure sensors, infusion pumps</li> </ul> <p>In each case, the microcontroller monitors inputs (like sensors or buttons), makes decisions via code, and triggers outputs (like motors, lights, or communications).</p>"},{"location":"chapters/chapter-1/#why-this-book-uses-the-pic24fj64ga002","title":"Why This Book Uses the PIC24FJ64GA002","text":"<p>This textbook focuses on the PIC24FJ64GA002, a 16-bit microcontroller from Microchip\u2019s PIC24 family. It strikes an ideal balance between complexity and learnability \u2014 advanced enough to support meaningful projects, but simple enough to teach the fundamentals of embedded systems clearly.</p> <p>The PIC24FJ64GA002 is widely used in academic and industry settings due to its:</p> <ul> <li>\u2705 Well-documented architecture</li> <li>\u2705 Rich set of on-chip peripherals</li> <li>\u2705 Smooth integration with MPLAB X IDE and the XC16 compiler</li> <li>\u2705 Strong ecosystem of tools, libraries, and example code</li> </ul>"},{"location":"chapters/chapter-1/#key-features-based-on-the-datasheet","title":"Key Features (Based on the Datasheet)","text":"Feature Description CPU Architecture 16-bit modified Harvard architecture Flash Memory 64 KB RAM 8 KB I/O Pins 24 I/O capable pins (in a 28 package pin) Timers Up to five 16-bit timers Communication UART, SPI, I2C ADC 10-bit resolution, up to 13 input channels Interrupt System Multi-priority vectored interrupt system Clock Options Internal and external oscillators (up to 32 MHz) Operating Voltage 2.0V to 3.6V <p>This microcontroller provides the right level of abstraction for learning low-level control, hardware interfacing, and system timing \u2014 without overwhelming new developers.</p> <p>\ud83d\udcce For full details, refer to the official PIC24FJ64GA002 Datasheet.</p>"},{"location":"chapters/chapter-1/#pic24fj64ga002-architecture-overview","title":"PIC24FJ64GA002 Architecture Overview","text":"<p>The PIC24FJ64GA002 is based on a 16-bit modified Harvard architecture. This means that it has separate memory spaces for instructions and data, which allows for more efficient fetching and execution of instructions.</p> <p>Unlike traditional Harvard designs, the PIC24 allows for flexible memory operations \u2014 instructions can access data memory, and certain instructions (like table reads/writes) can access program memory.</p>"},{"location":"chapters/chapter-1/#core-components-of-the-architecture","title":"Core Components of the Architecture","text":"Component Description CPU 16-bit core with a 2-stage pipeline (fetch/execute) Flash Memory 64 KB of non-volatile memory for storing program instructions RAM 8 KB of data memory for variables and temporary storage Registers 16 working registers (W0\u2013W15), used for all operations Stack Software-managed via dedicated stack pointer (no hardware push/pop instructions) Peripherals Timers, UART, SPI, I2C, ADC, output compare, input capture, etc. Interrupts Vectored interrupt system with multiple priority levels"},{"location":"chapters/chapter-1/#harvard-vs-von-neumann","title":"Harvard vs. Von Neumann","text":"<p>Most desktop computers use the Von Neumann architecture, where code and data share the same memory space. In contrast, the Harvard model separates them:</p> Feature Harvard Architecture Von Neumann Instruction Memory \u2705 Separate \u274c Shared Data Memory \u2705 Separate \u2705 Shared Performance \u2705 Faster (no bus conflict) \u274c Slower <p>The PIC24's modified Harvard design enables faster and more efficient execution for embedded systems.</p>"},{"location":"chapters/chapter-1/#register-centric-design","title":"Register-Centric Design","text":"<p>Most operations on the PIC24 use the 16 working registers (W0 to W15). These are: - Used as operands in arithmetic, logic, and data movement instructions - Referenced directly in assembly code - Some registers have special purposes (e.g., W15 is often used as the stack pointer)</p> <p>We'll explore register usage and memory addressing in more detail in the next chapter.</p>"},{"location":"chapters/chapter-2/","title":"Chapter 2: Assembly &amp; Addressing Modes","text":""},{"location":"chapters/chapter-2/#why-learn-assembly","title":"Why Learn Assembly?","text":"<p>Modern embedded systems are often programmed in high-level languages like C, but understanding assembly language is crucial for writing efficient, low-level code and truly mastering how a microcontroller works.</p> <p>Assembly gives you:</p> <ul> <li>\ud83d\udd0d Complete control over the CPU, memory, and peripheral access</li> <li>\u26a1 Performance optimizations that compilers can't always guarantee</li> <li>\ud83e\udde0 A deep understanding of what C code is actually doing \"under the hood\"</li> <li>\ud83d\udee0\ufe0f The ability to debug complex timing or hardware interaction issues</li> </ul> <p>Most high-level code on microcontrollers is eventually compiled into assembly \u2014 learning how to read and write it directly unlocks a new level of skill and insight.</p>"},{"location":"chapters/chapter-2/#pic24-assembly-basics","title":"PIC24 Assembly Basics","text":"<p>The PIC24 family uses a RISC (Reduced Instruction Set Computing) assembly language with a 16-bit word size. Each instruction typically executes in one cycle (excluding branching or memory fetches).</p> <p>In this chapter, we\u2019ll explore: - The basic syntax of PIC24 assembly - How data is moved between memory and registers - The different addressing modes (immediate, direct, indirect) - How to perform arithmetic and logical operations</p>"},{"location":"chapters/chapter-2/#basic-instruction-structure-syntax","title":"Basic Instruction Structure &amp; Syntax","text":"<p>Each PIC24 assembly instruction follows a simple, consistent structure:</p> <p><pre><code>OPCODE  OPERAND1, OPERAND2\n</code></pre> Where: - OPCODE is the operation to perform (e.g. MOV, ADD, SUB, etc.) - OPERAND1 is the source operand (what's being used for the operation) - OPERAND2 is the destination operand (where the result is stored)</p> <p>Example: Moving Data Between Registers <pre><code>    MOV     W1, W0      ; Copy contents of W1 into W0\n    MOV     #10, W2     ; Load the literal value 10 into W2\n</code></pre></p> <p>In the previous example:  - MOV W1, W0 takes the contents of W1 and stores it in W0 - MOV #10, W2 loads the immdeiate value 10 into W2</p> <p>Use semicolons (;) for comments in the PIC24 assembly: <pre><code>    CLR     W3          ; Clear W3 (set to zero)\n    ADD     W1, W2      ; Add W1 to W2 (result stored in W2)\n</code></pre></p>"},{"location":"chapters/chapter-2/#working-registers-w0w15","title":"Working Registers (W0\u2013W15)","text":"<p>PIC24 has 16 general-purpose working registers used for arithmetic, data movement, memory access, and stack operations.</p> Register Purpose Notes W0\u2013W13 General-purpose registers Used for operations, temporary storage W14 Frame Pointer (FP) Typically points to current stack frame W15 Stack Pointer (SP) Automatically updated on function calls"},{"location":"chapters/chapter-2/#common-pic24-assembly-instructions","title":"Common PIC24 Assembly Instructions","text":"Instruction Description <code>MOV</code> Move data between registers or from an immediate value <code>ADD</code> Add two registers or a register and a literal <code>SUB</code> Subtract one register from another <code>CLR</code> Clear a register (set it to 0) <code>INC</code> / <code>DEC</code> Increment / Decrement a register <code>CP</code> Compare two values (affects flags; used with branches)"},{"location":"chapters/chapter-2/#addressing-modes-in-pic24","title":"Addressing Modes in PIC24","text":"<p>Addressing modes define how data is accessed in an instruction. The PIC24 supports several flexible addressing modes, giving you control over where data comes from and how it's used.</p> <p>Here are the most common addressing modes:</p>"},{"location":"chapters/chapter-2/#1-immediate-addressing","title":"1. Immediate Addressing","text":"<p>Loads a constant (literal) value directly into a register.</p> <pre><code>MOV     #25, W0     ; #25 is a literal constant.\n                    ; Common for setting values or initializing data.\n</code></pre>"},{"location":"chapters/chapter-2/#2-register-direct","title":"2. Register Direct","text":"<p>Uses a working register directly as the source or desination.</p> <pre><code>MOV     W1, W2      ; Copy contents of W1 into W2.\n                    ; Fastest and simplest form.\n                    ; All operations using Wn (W0\u2013W15) fall under this mode.\n</code></pre>"},{"location":"chapters/chapter-2/#3-register-indirect","title":"3. Register Indirect","text":"<p>Uses a register as a pointer to data in memory</p> <pre><code>MOV     [W5], W0    ; Move value from address pointed to by W5 into W0.\n                    ; W5 contains the address, not the value itself.\n</code></pre>"},{"location":"chapters/chapter-2/#4-indirect-with-post-increment","title":"4. Indirect with Post-Increment","text":"<p>Automatically increments the pointer after the operation</p> <pre><code>MOV     [W6++], W1  ; Move from memory pointed to by W6 into W1.\n                    ; Then W6 = W6 + 2.\n                    ; Useful for reading data from arrays (word-aligned).\n</code></pre>"},{"location":"chapters/chapter-2/#5-indirect-with-pre-increment","title":"5. Indirect with Pre-Increment","text":"<p>Decrements the pointer before accessing the memory</p> <pre><code>MOV     [--W6], W1  ; W6 = W6 - 2, then move from new address into W1.\n                    ; Useful when reading a stack or traversing backward.\n</code></pre>"},{"location":"chapters/chapter-2/#6-literalwn","title":"6. Literal+Wn","text":"<p>Adds a literal offset to a base register</p> <pre><code>MOV     [W8 + 4], W0   ; Move from address (W8 + 4) into W0.\n                       ; Often used for structure fields or array access.\n                       ; Literal must be word-aligned (multiple of 2).\n</code></pre>"},{"location":"chapters/chapter-2/#chapter-summary","title":"Chapter Summary","text":"<p>In this chapter, we explored the fundamentals of PIC24 assembly language and how to work directly with the CPU's registers and memory.</p>"},{"location":"chapters/chapter-2/#self-check-quiz-styled-with-uppercase-letters","title":"Self-Check Quiz (Styled with Uppercase Letters)","text":"Which instruction correctly loads literal 25 into W5? <ol> <li>MOV W5, #25</li> <li>MOV [W5], 25</li> <li>MOV #25, W5</li> <li>LOAD 25 \u2192 W5</li> </ol> <p>Answer: C. <code>MOV #25, W5</code></p> Which instruction correctly loads literal 10 into W0? <p>```asm</p> Show Options <p> 1. <code>MOV W0, #10</code> 2. <code>MOV #10, W0</code> 3. <code>LOAD 10 \u2192 W0</code> 4. <code>MOV #W0, 10</code> </p> <p>Answer: B. <code>MOV #10, W0</code></p>"},{"location":"chapters/chapter-2/#practice-prompt","title":"Practice Prompt","text":"<p>Write a short PIC24 assembly program that:</p> <ul> <li>Loads the values 5 and 10 into two registers  </li> <li>Adds them together  </li> <li>Stores the result in <code>W2</code></li> </ul> <p>Try it yourself before revealing the solution!</p> Show Solution <pre><code>MOV     #10, W0      ; Load 10 into W0\nMOV     #5, W1       ; Load 5 into W1\nADD     W0, W1       ; Add W0 to W1 \u2192 W1 = 15\nMOV     W1, W2       ; Store the result in W2\n</code></pre>"},{"location":"chapters/chapter-2/#what-you-learned","title":"What You Learned:","text":"<ul> <li>The basic syntax of PIC24 assembly instructions</li> <li>The role of working registers (<code>W0\u2013W15</code>)</li> <li>How to use the MOV, <code>ADD</code>, <code>SUB</code>, and <code>CLR</code> instructions</li> <li>The key addressing modes:</li> <li>Immediate</li> <li>Register direct</li> <li>Indirect with pre/post increment</li> <li>Literal offset + register</li> </ul>"},{"location":"chapters/chapter-2/#why-it-matters","title":"Why It Matters:","text":"<ul> <li>Assembly gives you precise control over hardware</li> <li>It's the foundation for understanding how C code interacts with hardware</li> <li>You\u2019ll need these concepts when working with the stack, interrupts, and I/O peripherals</li> </ul>"},{"location":"chapters/chapter-2/#up-next-stack-call-and-function-frames","title":"Up Next: Stack, Call, and Function Frames","text":"<p>In Chapter 3, we'll explore: - How the PIC24 manages function calls - The use of <code>W14</code> as the frame pointer - How the stack works for passing data and preserving state</p> <p>You'll learn to set up and tear down stack frames manually \u2014 a crucial skill for writing low-level code that\u2019s reliable and efficient.</p> <ol> <li>Alpha</li> <li>Bravo</li> <li>Charlie</li> </ol>"},{"location":"chapters/chapter-3/","title":"Chapter 3: Branching &amp; Loops in Assembly","text":""},{"location":"chapters/chapter-3/#section-1-controlling-the-flow-of-execution","title":"Section 1: Controlling the Flow of Execution","text":"<p>Until now, we\u2019ve written assembly code that executes linearly \u2014 one instruction after another from top to bottom. But real programs rarely follow a straight path. They make decisions, repeat tasks, and jump between sections of code.</p> <p>To do this in assembly, we use:</p> <ul> <li>Branching to jump to different parts of the code</li> <li>Conditional instructions to decide when to branch</li> <li>Loops to repeat actions until a condition is met</li> </ul> <p>Just like in higher-level languages (<code>if</code>, <code>while</code>, <code>for</code>), branching and looping let us create flexible, reactive, and dynamic programs \u2014 but we build them manually in assembly using a combination of labels, comparison instructions, and branch instructions.</p>"},{"location":"chapters/chapter-3/#real-world-example-polling-a-button","title":"Real-World Example: Polling a Button","text":"<p>Let\u2019s say you want your microcontroller to wait until a button is pressed, and then turn on an LED. That requires:</p> <ul> <li>Repeatedly checking a pin (a loop)</li> <li>Branching based on whether the pin is high or low (a decision)</li> </ul> <p>In assembly, that logic would look like:</p> <p><pre><code>CheckButton:\n    MOV     PORTB, W0         ; Load PORTB into W0\n    AND     W0, #0x0001, W0   ; Mask all but bit 0 (RB0)\n    CP      W0, #0            ; Is RB0 low?\n    BEQ     CheckButton       ; If yes, button not pressed \u2192 loop back\n\n    BSET    LATB, #1          ; Set RB1 (turn on LED)\n</code></pre> This example shows both a loop(keep checking) and a branch(skip ahead once the button is pressed)</p> <p>\u26a0\ufe0f Avoid using <code>INC LATB</code> or <code>ADD LATB, #value</code></p> <p>These instructions modify the entire 16-bit latch, which can unintentionally affect multiple output pins. For example:</p> <ul> <li>If only RB1 should be set, <code>INC</code> might toggle RB0 or clear RB1 depending on the current value.</li> <li>Using arithmetic operations doesn\u2019t preserve the state of other bits.</li> </ul>"},{"location":"chapters/chapter-3/#section-2-unconditional-branching","title":"\ud83e\uddf1Section 2: Unconditional Branching","text":"<p>In assembly, unconditional branching allows you to jump to another part of your program without checking any condition. It\u2019s like saying, \u201cGo here, no matter what.\u201d</p> <p>This is useful for:</p> <ul> <li>Skipping over code</li> <li>Repeating a block (with labels)</li> <li>Structuring loops</li> <li>Returning to a main loop after an operation</li> </ul>"},{"location":"chapters/chapter-3/#bra-branch-always","title":"\ud83d\udd39 <code>BRA</code> \u2014 Branch Always","text":"<p>The <code>BRA</code> instruction causes the program to jump to a label. Execution continues from that label as if the code above it didn\u2019t exist.</p> <p><pre><code>BRA     MainLoop \n</code></pre> BRA uses relative addressing (i.e. jump a certain number of instruction forward/backward).  A tip for BRA is to use it for most control flow and loops.</p>"},{"location":"chapters/chapter-3/#call-and-return-preview","title":"\ud83d\udd39 <code>Call</code> and <code>Return</code> (Preview)","text":"<p>You can also branch to a subroutine using <code>Call</code>, which saves the current program counter(PC) onto the stack. When the subroutine is done, it uses RETURN to jump back.</p> <pre><code>CALL    DelayLoop    ; Jump to subroutine\nRETURN               ; Return from it\n</code></pre> <p>We'll cover the stack and subroutines more deeply in Chapter 4, so for now just think of <code>CALL</code> as a way to jump to a reusable block of code and RETURN as a way to come back. </p>"},{"location":"chapters/chapter-3/#summary","title":"\ud83e\udde0 Summary","text":"Instruction Purpose <code>BRA</code> Unconditional branch (relative) <code>CALL</code> Branch to subroutine (saves return address on stack) <code>RETURN</code> Return from subroutine (restores execution flow)"},{"location":"chapters/chapter-3/#section-3-conditional-branching","title":"Section 3: Conditional Branching","text":"<p>Sometimes, you want to branch only if a condition is true \u2014 like jumping to a section of code only if two values match, or only if a counter hasn\u2019t hit zero yet.</p> <p>To do that, PIC24 uses a two-step process: 1. Compare values using the <code>CP</code> (Compare) instruction 2. Use a conditional branch like <code>BNE</code> or <code>BEQ</code> based on the result</p>"},{"location":"chapters/chapter-3/#step-1-compare-with-cp","title":"\ud83d\udd39 Step 1: Compare with <code>CP</code>","text":"<p>The <code>CP</code> instruction compares two values by internally performing a subtraction (without storing the result). It sets status flags (Zero, Negative, Overflow, etc.) based on the result.</p> <p><pre><code>CP      W0, W1     ; Compare W0 to W1\n</code></pre> After this, the processor knows whether <code>W0 == W1</code>, <code>W0 &lt; W1</code>, or <code>W0 &gt; W1</code></p>"},{"location":"chapters/chapter-3/#step-2-branch-based-on-flags","title":"\ud83d\udd39 Step 2: Branch Based on Flags","text":"<p>Once <code>CP</code> sets the condition flags, you can use one of several conditional branch instructions:</p> Instruction Meaning Condition Tested <code>BEQ</code> Branch if equal Z = 1 (Zero flag) <code>BNE</code> Branch if not equal Z = 0 <code>BLT</code> Branch if less than (signed) N \u2260 V <code>BGE</code> Branch if greater/equal N = V <code>BRA</code> Branch always (no condition) \u2014 <pre><code>CP      W0, #10      ; Compare W0 to literal 10\nBEQ     MatchLabel   ; If W0 == 10, jump to MatchLabel\n    ; This code runs if W0 \u2260 10\n\nMatchLabel:\n    ; This code runs only if W0 == 10\n</code></pre>"},{"location":"chapters/chapter-3/#what-are-condition-flags","title":"\ud83e\udde0 What Are Condition Flags?","text":"<p>When the PIC24 performs a compare, it updates specific bits in the Status Register (SR):</p> <ul> <li>Z (Zero): Set if the result is zero (values matched)  </li> <li>N (Negative): Set if result was negative  </li> <li>C (Carry) and V (Overflow): Used in signed/unsigned comparisons  </li> </ul> <p>These flags are not written directly by your code \u2014 they\u2019re set automatically by instructions like <code>CP</code>, <code>SUB</code>, or <code>ADD</code>.</p>"},{"location":"chapters/chapter-3/#section-4-loops-in-assembly","title":"Section 4: Loops in Assembly","text":"<p>Loops are a fundamental programming structure that let you repeat code until a condition is met. In high-level languages, we use constructs like <code>for</code> or <code>while</code>. In assembly, we build loops manually using:</p> <ul> <li>A label to mark the start of the loop</li> <li>A comparison (<code>CP</code>)</li> <li>A conditional branch (<code>BNE</code>, <code>BEQ</code>, etc.)</li> </ul>"},{"location":"chapters/chapter-3/#counting-down-example","title":"\ud83d\udd39 Counting Down Example","text":"<p>This loop counts from 3 down to 0 and stops when the counter reaches zero:</p> <p><pre><code>    MOV     #3, W0         ; Initialize counter to 3\n\nLoopStart:\n    ; [Insert code you want to repeat here]\n\n    DEC     W0, W0         ; Decrement counter\n    CP      W0, #0         ; Is counter zero?\n    BNE     LoopStart      ; If not, repeat loop\n</code></pre> This loop executes 3 times with W0 values: 2, 1, 0</p>"},{"location":"chapters/chapter-3/#counting-up-example","title":"\ud83d\udd39 Counting Up Example","text":"<p>If you want to count up instead:</p> <pre><code>    MOV     #0, W0         ; Start at 0\n\nLoopStart:\n    ; [Repeat logic here]\n\n    INC     W0, W0         ; Increment counter\n    CP      W0, #4         ; Stop when W0 reaches 4\n    BNE     LoopStart\n</code></pre> <p>This runs the loop while W0 = 0,1,2,3 - a total of 4 iterations.</p>"},{"location":"chapters/chapter-3/#why-assembly-loops-require-manual-control","title":"\ud83d\udd39 Why Assembly Loops Require Manual Control","text":"<p>Unlike C or Python, assembly doesn\u2019t have <code>while</code>, <code>for</code>, or <code>do...while</code> built in. But using just a few instructions, you can build any loop structure:</p> High-Level Idea Assembly Equivalent <code>while (x != 0)</code> label + <code>CP</code> + <code>BNE</code> <code>for (i = 0; i &lt; 4; i++)</code> <code>MOV</code> + label + <code>INC</code> + <code>CP</code> + <code>BNE</code> Infinite loop label + <code>BRA label</code>"},{"location":"chapters/chapter-3/#looping-summary","title":"Looping Summary:","text":"<ul> <li>Loops require a counter, a label, a comparison, and a branch.</li> <li><code>BNE</code> is commonly used to repeat while not equal to a target.</li> <li>You can loop upward, downward, or infinitely depending on the logic.</li> <li>Assembly loops give you full control, but also require more careful setup.</li> </ul>"},{"location":"chapters/chapter-3/#section-5-labeling-and-structure-tips","title":"Section 5: Labeling and Structure Tips","text":"<p>In assembly programming, labels are used to name a location in code that you can jump to using <code>BRA</code>, <code>CALL</code>, or conditional branches.</p> <p>They\u2019re the foundation for loops, subroutines, and organizing non-linear control flow.</p>"},{"location":"chapters/chapter-3/#defining-and-using-labels","title":"\ud83d\udd39 Defining and Using Labels","text":"<p>A label is a name followed by a colon <code>:</code>. It marks a position in your program.</p> <p><pre><code>Start:\n    MOV     #3, W0\n    BRA     Start         ; Jumps back to Start\n</code></pre> You can branch to a label anywhere in your program - forward or backward.</p>"},{"location":"chapters/chapter-3/#good-labeling-habits","title":"Good Labeling Habits","text":"<p>To keep your code readable and maintainable, follow these practices: </p> <ul> <li> <p>Use descriptive names   \u2192 e.g., <code>LoopStart</code>, <code>CheckDone</code>, <code>RetryLimit</code> \u2014 avoid generic labels like <code>L1</code>, <code>L2</code></p> </li> <li> <p>Align labels to the left margin   \u2192 Makes them easy to see when scanning your code</p> </li> <li> <p>Indent instructions beneath labels   \u2192 Improves visual clarity and shows structure</p> </li> <li> <p>Choose a consistent style   \u2192 Capitalized (<code>WAIT_LOOP:</code>) or camelCase (<code>waitLoop:</code>), just keep it uniform</p> </li> <li> <p>Use <code>NOP</code> for debugging or timing padding   \u2192 Safe spot for breakpoints or delay without affecting program logic</p> </li> </ul>"},{"location":"chapters/chapter-3/#using-nop-for-debugging","title":"Using <code>NOP</code> for Debugging","text":"<p>The <code>NOP</code> instruction (\"No Operation) does nothing - it simply consumes a clock cycle.</p> <p>It's useful for: </p> <ul> <li>Setting breakpoints during debugging</li> <li>Adding timing delays (in loops)</li> <li>Temporarily padding out code to preserve layout</li> </ul> <pre><code>NOP     ; Do nothing - can be a good place to break in debugger\n</code></pre>"},{"location":"chapters/chapter-3/#why-structure-matters","title":"Why Structure Matters","text":"<p>Assembly doesn\u2019t give you much abstraction \u2014 so clarity is your responsibility. Clean labels, indentation, and comments go a long way in making your code understandable \u2014 especially when debugging or returning to it later.</p>"},{"location":"chapters/chapter-3/#test-your-understanding","title":"\u2705 Test Your Understanding","text":"<p>Let\u2019s check your grasp of conditional branching and loops with a quick question.</p>"},{"location":"chapters/chapter-3/#quiz-how-many-times-does-the-loop-run","title":"\ud83e\udde0 Quiz: How Many Times Does the Loop Run?","text":"<pre><code>MOV     #4, W0\nLoop:\n    DEC     W0, W0\n    CP      W0, #0\n    BNE     Loop\n</code></pre> <ol> <li>3  </li> <li>4  </li> <li>5  </li> <li>Infinite loop  </li> </ol> Show Answer <p>The correct answer is B (4).</p> <p>The loop runs as W0 takes the values: 3, 2, 1, 0 \u2014 which is 4 total iterations. After the final decrement to 0, <code>BNE</code> no longer branches.</p>"},{"location":"chapters/chapter-3/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Can you write a loop that counts from 0 to 3, storing each value to memory?</p> <p>Try to solve it yourself before expanding the answer below!</p> Click to show solution <p>```asm MOV     #0, W0           ; Initialize counter to 0 MOV     #addr, W1        ; Assume W1 holds base address of memory</p> <p>Loop:     MOV     W0, [W1]         ; Store current value at [W1]     INC     W0, W0     ADD     #2, W1, W1       ; Move to next memory location (word = 2 bytes)     CP      W0, #4     BNE     Loop             ; Repeat until W0 == 4     ```</p> <pre><code>This loop stores the values 0, 1, 2, 3 into consecutive memory locations.\n</code></pre>"},{"location":"chapters/chapter-4/","title":"Chapter 4: Stack and Subroutine Calls","text":""},{"location":"chapters/chapter-4/#section-1-what-is-a-stack","title":"Section 1: What is a Stack?","text":"<p>A stack is a special kind of data structure that operates on a Last In, First Out (LIFO) principle \u2014 the last item you place on the stack is the first one to be removed.</p>"},{"location":"chapters/chapter-4/#real-world-analogy","title":"\ud83d\udd01 Real-World Analogy","text":"<p>Think of a stack of plates in a cafeteria: - You push a clean plate on top of the pile - You pop the top plate off when someone takes one - You can't grab a plate from the middle \u2014 only the top!</p> <p>This \"top-first\" behavior is exactly how the stack works in your microcontroller.</p>"},{"location":"chapters/chapter-4/#why-do-we-need-a-stack","title":"\ud83e\uddf1 Why Do We Need a Stack?","text":"<p>Stacks are used any time the program needs to pause what it's doing, remember something, and come back to it later.</p> <p>In the PIC24, the stack is used to: - Store the return address when calling a subroutine - Temporarily hold register values during nested function calls - Save context during interrupts</p> <p>If you didn't have a stack, calling one function from another \u2014 or returning from an interrupt \u2014 would be extremely difficult (if not impossible) to manage.</p>"},{"location":"chapters/chapter-4/#key-operations","title":"\ud83e\udded Key Operations","text":"Term Meaning <code>PUSH</code> Store a value on the top of the stack <code>POP</code> Remove the top value from the stack <code>CALL</code> Push return address, jump to subroutine <code>RETURN</code> Pop return address, continue execution <p>These operations are handled automatically during function calls \u2014 but you can also perform them manually in assembly.</p> <p>In the next section, we'll explore how the PIC24 handles subroutine calls using the stack, and how to trace exactly what happens when a <code>CALL</code> and <code>RETURN</code> are executed.</p>"},{"location":"chapters/chapter-4/#section-2-the-call-stack-in-assembly","title":"Section 2: The Call Stack in Assembly","text":"<p>Whenever your program executes a subroutine call, the processor must remember where to return after the subroutine finishes. To do this, it uses the stack.</p>"},{"location":"chapters/chapter-4/#what-happens-during-a-call","title":"\ud83d\udd39 What Happens During a <code>CALL</code>","text":"<p>When you execute a <code>CALL</code> instruction:</p> <pre><code>CALL    MyFunction\n</code></pre> <p>The pic 24 automatically performs the following:   - Pushes the return address onto the stack.   - Jumps to the MyFunction label.</p> <p>Later when the subroutine finishes, a <code>RETURN</code> instruction:   - Pops the return address off the stack   - Resumes execution from that address <pre><code>RETURN\n</code></pre></p>"},{"location":"chapters/chapter-4/#stack-behavior-during-function-calls","title":"Stack Behavior During Function Calls","text":"<p>Let's walk through a basic example:</p> <pre><code>Main:\n    CALL    DoSomething\n    ; Execution resumes here after RETURN\n\nDoSomething:\n    ; Function logic here\n    RETURN\n</code></pre> <p>What the Stack Looks Like:</p> Stack Top Contents \u2b06 Growing Downward Address of <code>Main+2</code> (Return to next line)"},{"location":"chapters/chapter-4/#you-dont-have-to-push-return-address-yourself","title":"You Don't Have to Push Return Address Yourself","text":"<p>The best part? You don't need to manually push/pop the return address \u2014 the CALL and RETURN instructions handle it automatically for you. That\u2019s what makes writing subroutines manageable.</p>"},{"location":"chapters/chapter-4/#section-3-stack-pointers-in-the-pic24","title":"Section 3: Stack Pointers in the PIC24","text":"<p>In the PIC24 architecture, the stack is accessed through special-purpose working registers. Understanding these is key to tracing subroutine behavior and building your own call structures.</p>"},{"location":"chapters/chapter-4/#w15-the-stack-pointer-sp","title":"\ud83d\udd39 W15 \u2014 The Stack Pointer (SP)","text":"<p>The register <code>W15</code> is automatically used by the processor as the stack pointer. It always points to the top of the stack in memory.</p> <ul> <li>When you push data, it stores the value at <code>[W15]</code> and increments (post-increment)</li> <li>When you pop data, it decrements first and then reads from <code>[W15]</code> (pre-decrement)</li> </ul>"},{"location":"chapters/chapter-4/#example-manual-pushpop","title":"Example: Manual Push/Pop","text":"<p><pre><code>MOV     #0x1234, W0\nMOV     W0, [W15++]      ; Push W0 onto stack\n\nMOV     [--W15], W1      ; Pop from stack into W1\n</code></pre> You usually don\u2019t need to manipulate W15 directly unless you're saving/restoring temporary values in custom subroutines.</p>"},{"location":"chapters/chapter-4/#w14-the-frame-pointer-optional","title":"\ud83d\udd39 W14 \u2014 The Frame Pointer (Optional)","text":"<p>By convention, <code>W14</code> is often used as a frame pointer, especially in higher-level language support (like C). It can be useful when:</p> <ul> <li>Managing local variables relative to a base offset  </li> <li>Navigating function call frames more easily in complex call chains  </li> </ul> <p>\ud83d\udcdd Note: The frame pointer is not required for basic assembly subroutines, but it can help with stack-traceability in deeper projects.</p>"},{"location":"chapters/chapter-4/#summary-of-stack-registers","title":"\ud83d\udcca Summary of Stack Registers","text":"Register Role Usage Example <code>W15</code> Stack Pointer (SP) <code>MOV W0, [W15++]</code> <code>W14</code> Frame Pointer (FP) User-defined (optional)"},{"location":"chapters/chapter-4/#section-4-writing-and-tracing-a-subroutine","title":"Section 4: Writing and Tracing a Subroutine","text":"<p>Let\u2019s bring everything together and write a real subroutine that uses the call stack.</p> <p>We\u2019ll build a function that doubles a value passed in <code>W0</code>, and returns the result in <code>W0</code> \u2014 a simple example, but one that shows how function calls work under the hood.</p>"},{"location":"chapters/chapter-4/#step-1-main-program-calls-the-function","title":"\ud83d\udd39 Step 1: Main Program Calls the Function","text":"<pre><code>    MOV     #7, W0          ; Load 7 into W0\n    CALL    DoubleValue     ; Call subroutine to double W0\n    ; W0 now contains 14\n</code></pre> <p>When <code>CALL DoubleValue</code> is executed, the processor:  - Pushes the return address onto the stack  - Jumps to the label <code>DoubleValue</code></p>"},{"location":"chapters/chapter-4/#step-2-define-the-subroutine","title":"\ud83d\udd39 Step 2: Define the Subroutine","text":"<p><pre><code>DoubleValue:\n    ADD     W0, W0, W0      ; Double the value in W0\n    RETURN                  ; Return to the line after the CALL\n</code></pre> When <code>RETURN</code> executes:  - The processor pops the return address from the stack  - Execution resumes immediately after the <code>CALL</code></p>"},{"location":"chapters/chapter-4/#what-the-stack-looks-like","title":"\ud83e\uddea What the Stack Looks Like","text":"<p>Before <code>CALL DoubleValue</code>, the stack might look like this:</p> Stack Top Contents \u2b06 Growing Downward Address after CALL Return address \u2192 resume here <p>After <code>RETURN</code>, the address is popped off and the stack returns to its previous state.</p>"},{"location":"chapters/chapter-4/#notes","title":"\u2705 Notes","text":"<ul> <li>The value is passed in <code>W0</code>, and the result is returned in <code>W0</code>. This is a common calling convention for small assembly routines.  </li> <li>For more complex functions, you may also use <code>W1</code>, <code>W2</code>, or the stack itself to pass/return data.</li> </ul>"},{"location":"chapters/chapter-4/#section-5-visualizing-the-stack","title":"Section 5: Visualizing the Stack","text":"<p>Understanding how the stack grows and shrinks is essential for mastering subroutine calls and returns. Even though the processor handles most of the mechanics automatically, being able to mentally trace stack behavior will help you debug and write more reliable code.</p>"},{"location":"chapters/chapter-4/#how-the-stack-grows","title":"\ud83d\udd39 How the Stack Grows","text":"<p>The PIC24 stack grows downward in memory \u2014 that means each time something is pushed, the stack pointer (<code>W15</code>) points to a lower address.</p> <p>Every time you <code>CALL</code> a function:</p> <ul> <li>The return address is pushed onto the stack</li> <li>Any manually saved data (like temporary registers) can also be pushed</li> </ul> <p>When you <code>RETURN</code>:</p> <ul> <li>The return address is popped, and execution resumes where it left off</li> <li>If you saved anything manually, you must also restore it before returning</li> </ul>"},{"location":"chapters/chapter-4/#example-two-nested-calls","title":"\ud83e\udded Example: Two Nested Calls","text":"<pre><code>Main:\n    CALL    A\n\nA:\n    CALL    B\n    RETURN\n\nB:\n    RETURN\n</code></pre>"},{"location":"chapters/chapter-4/#stack-behavior","title":"Stack Behavior:","text":"<ol> <li><code>CALL A</code> \u2192 pushes return address for <code>Main</code></li> <li>Inside <code>A</code>, <code>CALL B</code> \u2192 pushes return address for <code>A</code></li> <li><code>RETURN</code> from <code>B</code> \u2192 pops to <code>A</code></li> <li><code>RETURN</code> from <code>A</code> \u2192 pops to <code>Main</code></li> </ol>"},{"location":"chapters/chapter-4/#section-6-summary-and-best-practices","title":"Section 6: Summary and Best Practices","text":"<p>Now that you\u2019ve seen how the stack works and how subroutines are built in PIC24 assembly, here\u2019s what you should remember going forward:</p>"},{"location":"chapters/chapter-4/#key-takeaways","title":"\ud83e\udde0 Key Takeaways","text":"<ul> <li>The stack stores return addresses (and optionally local data) when calling subroutines.</li> <li><code>CALL</code> and <code>RETURN</code> handle stack push/pop automatically for return addresses.</li> <li><code>W15</code> is the stack pointer (SP) \u2014 it tracks the top of the stack and grows downward.</li> <li><code>W14</code> is commonly used as a frame pointer (FP) \u2014 useful for structured call frames or C-style stack frames.</li> <li>You can manually push/pop data using <code>[W15++]</code> and <code>[--W15]</code>.</li> </ul>"},{"location":"chapters/chapter-4/#best-practices-for-subroutines","title":"\u2705 Best Practices for Subroutines","text":"<ul> <li>\u2714\ufe0f Use <code>W0</code> to pass parameters and return values in small subroutines.</li> <li>\u2714\ufe0f Use <code>CALL</code>/<code>RETURN</code> for clean function separation.</li> <li>\u2714\ufe0f If you manually push registers (e.g. <code>W1</code>, <code>W2</code>), always restore them before returning.</li> <li>\u274c Avoid modifying <code>W15</code> directly \u2014 use auto-increment/decrement instead.</li> <li>\u2714\ufe0f Keep subroutines small and modular when possible.</li> <li>\u2714\ufe0f Comment your subroutine entry and exit points \u2014 especially when multiple calls are nested.</li> </ul> <p>In the next chapter, we\u2019ll expand your control over time with hardware timers and learn how to build precise time-based behavior in your programs using interrupts.</p>"},{"location":"chapters/chapter-4/#quiz-stack-and-subroutines","title":"\ud83e\udde0 Quiz: Stack and Subroutines","text":"<p>What happens to the stack when the following code is executed?</p> <p>```asm     CALL    Func1     ; do something     CALL    Func2     ; done</p> <p>Func1:     RETURN</p> <p>Func2:     RETURN</p> <ol> <li>The stack is unchanged \u2014 calls don\u2019t affect it  </li> <li>Two values are pushed to the stack and never removed  </li> <li>One return address is pushed and overwritten  </li> <li>Two return addresses are pushed, then popped in reverse order  </li> </ol> Show Answer <p>The correct answer is D.</p> <p>When <code>CALL Func1</code> is executed, the return address is pushed onto the stack. After <code>Func1</code> returns, the address is popped. The same happens with <code>Func2</code>.</p> <p>So, two return addresses are pushed and popped in reverse order \u2014 just like a stack (LIFO).</p>"},{"location":"chapters/chapter-4/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write a subroutine called <code>AddTen</code> that takes a number in <code>W0</code>, adds 10 to it, and returns the result (also in <code>W0</code>). Your main program should call <code>AddTen</code> with an initial value of <code>5</code>, and store the result in <code>W1</code>.</p> <p>Try writing it yourself before checking the solution!</p> Click to show solution <p>```asm ; Main Program MOV     #5, W0           ; Load value into W0 CALL    AddTen           ; Call subroutine MOV     W0, W1           ; Store result in W1</p> <p>; Subroutine</p> <p>AddTen:     ADD     W0, #10, W0      ; Add 10 to the value in W0     RETURN     ```</p>"},{"location":"chapters/chapter-5/","title":"Chapter 5: Timers and Interrupts","text":""},{"location":"chapters/chapter-5/#section-1-what-are-timers","title":"Section 1: What Are Timers?","text":"<p>Timers are built-in hardware modules that allow the microcontroller to track the passage of time. Unlike using <code>NOP</code> instructions or software loops for delays, hardware timers are far more precise, efficient, and interrupt-friendly.</p>"},{"location":"chapters/chapter-5/#what-timers-actually-do","title":"\ud83d\udd01 What Timers Actually Do","text":"<p>At their core, timers are just counters. They increment on each clock cycle (or prescaled clock cycle), and you can configure:</p> <ul> <li>When they start</li> <li>When they reset</li> <li>What value triggers an interrupt or event</li> <li>Whether they count continuously or one time</li> </ul>"},{"location":"chapters/chapter-5/#why-timers-matter","title":"\ud83e\udde0 Why Timers Matter","text":"<p>Timers are one of the most essential peripherals for real-world embedded systems. They allow your program to:</p> <ul> <li>Delay an operation for a fixed time</li> <li>Toggle LEDs at precise intervals (blinking)</li> <li>Measure durations between events (e.g., how long a button is pressed)</li> <li>Generate PWM (Pulse Width Modulation)</li> <li>Act as the heartbeat of an RTOS (Real-Time Operating System)</li> </ul>"},{"location":"chapters/chapter-5/#software-loops-vs-hardware-timers","title":"\u231a Software Loops vs Hardware Timers","text":"Method Accurate? Affects CPU? Good for... Software Delay \u274c \u2705 Yes Quick hacks, rough timing Hardware Timer \u2705 \u274c No Precise, real-time timing <p>\u2705 Timers are especially powerful when combined with interrupts, allowing your code to respond to time events without constantly checking them.</p> <p>In the next section, we\u2019ll explore how to configure and use timers on the PIC24 \u2014 including key registers and modes.</p>"},{"location":"chapters/chapter-5/#section-2-timer-configuration-on-the-pic24","title":"Section 2: Timer Configuration on the PIC24","text":"<p>The PIC24 family includes multiple timers (Timer1, Timer2, etc.) that can be configured using special function registers (SFRs). To make a timer do anything useful, you\u2019ll need to configure:</p> <ul> <li>The timer control register (e.g., <code>T1CON</code>)</li> <li>The period register (<code>PRx</code>) \u2014 when the timer should reset</li> <li>The timer count register (<code>TMRx</code>) \u2014 current value</li> <li>Optional: prescaler, interrupt enable, and clock source</li> </ul>"},{"location":"chapters/chapter-5/#basic-timer-setup-steps","title":"\ud83d\udd39 Basic Timer Setup Steps","text":"<p>Here\u2019s a typical configuration for a simple periodic timer:</p> <pre><code>T1CON = 0                // Common practice to set everything low before modifying the bits you do care about\nT1CONbits.TCKPS = 0b10;     // Prescaler = 1:64\nPR1 = 15625;             // Set period register (timer resets at this value)\nTMR1 = 0;                // Clear the timer count\nT1CONbits.TON = 1;       // Turn on Timer1\n</code></pre>"},{"location":"chapters/chapter-5/#key-timer-registers-for-timerx","title":"\ud83e\udde0 Key Timer Registers (for TimerX)","text":"Register Description <code>T\u27e8x\u27e9CON</code> Timer Control Register for TimerX <code>PR\u27e8x\u27e9</code> Period Register \u2014 timer resets at this value <code>TMR\u27e8x\u27e9</code> Timer Count Register (increments over time) <code>IFS0bits.T\u27e8x\u27e9IF</code> Interrupt Flag \u2014 set when timer expires <code>IEC0bits.T\u27e8x\u27e9IE</code> Interrupt Enable bit <p>\ud83d\udd01 Replace \u27e8x\u27e9 with the timer number: 1, 2, 3, etc.</p>"},{"location":"chapters/chapter-5/#prescaler-controlling-timer-speed","title":"\ud83d\udd27 Prescaler: Controlling Timer Speed","text":"<p>Most timers have a prescaler, which divides the system clock slow down how fast the timer increments.  For example:</p> Prescaler Description 1:1 Fastest (no division) 1:8 8\u00d7 slower 1:64 64\u00d7 slower 1:256 Slowest \u2014 256\u00d7 slower <p>Choose a prescaler so your period fits nicely within a 16-bit register (0\u201365535).</p> <p>Tip: If your timer counts too fast, try increasing the prescaler or switching to a 32-bit timer by combining two 16-bit timers (e.g., Timer2 + Timer3).</p> <p>In the next section, we\u2019ll explore interrupts \u2014 and how they make timers even more powerful by allowing your code to respond asynchronously when the timer expires.</p>"},{"location":"chapters/chapter-5/#section-3-interrupts-responding-to-events","title":"Section 3: Interrupts - Responding to Events","text":"<p>In a real-world embedded system, you often want your code to respond as soon as something happens \u2014 without constantly checking for it. That\u2019s where interrupts come in.</p> <p>An interrupt is a hardware-triggered event that causes the processor to pause what it\u2019s doing and run a special function called an Interrupt Service Routine (ISR).</p>"},{"location":"chapters/chapter-5/#why-use-interrupts","title":"\ud83d\udd39 Why Use Interrupts?","text":"<p>Without interrupts, you'd need to use polling \u2014 continuously checking for a condition inside a loop:</p> <pre><code>while (!timerExpired) {\n    // check again and again...\n}\n</code></pre> <p>This wastes CPU cycles. Instead, interrupts allow the microcontroller to do other things and only respond when needed. </p>"},{"location":"chapters/chapter-5/#how-interrupts-work-in-pic24","title":"\ud83d\udd27 How Interrupts Work in PIC24","text":"<p>When an interrupt occurs (e.g., a timer hits <code>PRx</code>):</p> <ol> <li>The CPU pauses the main program</li> <li>The return address and some key registers are pushed onto the stack</li> <li>The ISR is executed (defined by you)</li> <li>A <code>RETFIE</code> (Return from Interrupt) instruction:</li> <li>Pops saved values from the stack</li> <li>Resumes main code exactly where it left off</li> </ol>"},{"location":"chapters/chapter-5/#example-timer1-interrupt-flow","title":"Example: Timer1 Interrupt Flow","text":"<p>Assuming you've enabled the Timer1 interrupt:</p> <pre><code>void __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    IFS0bits.T1IF = 0;  // Clear interrupt flag\n    // Handle event (e.g., toggle LED)\n}\n</code></pre> <p>This function runs automatically every time Timer1. <code>IFS0bits.T1IF</code> must be cleared manually at the beginning of the ISR to prevent retriggering </p>"},{"location":"chapters/chapter-5/#interrupt-stack-behavior","title":"\ud83d\udce6 Interrupt Stack Behavior","text":"Action What Happens Interrupt occurs Return address + status pushed to stack ISR runs Executes your code RETFIE Pops return data and resumes main program <p>This is very similar to a <code>CALL</code>, but initiated by the hardware rather than code. </p>"},{"location":"chapters/chapter-5/#section-4-blinking-an-led-with-a-timer-interrupt","title":"Section 4: Blinking an LED with a Timer Interrupt","text":"<p>Let\u2019s build one of the most classic embedded applications: blinking an LED at regular intervals using a hardware timer and interrupt.</p>"},{"location":"chapters/chapter-5/#goal","title":"\ud83d\udd39 Goal","text":"<ul> <li>Use Timer1 to generate an interrupt every 500 ms</li> <li>Each time the interrupt occurs, toggle an LED connected to PORTB, bit 0</li> </ul>"},{"location":"chapters/chapter-5/#configuration-timer-interrupt-gpio","title":"\ud83d\udee0\ufe0f Configuration: Timer + Interrupt + GPIO","text":"<p>Here\u2019s a complete example:</p> <pre><code>// Setup in main()\nTRISBbits.TRISB0 = 0;         // Set RB0 as output\nLATBbits.LATB0 = 0;           // Initialize LED OFF\n\nT1CONbits.TCKPS = 3;          // Prescaler 1:256\nPR1 = 31250;                  // 500ms interval with Fcy = 16MHz\nTMR1 = 0;\n\nIFS0bits.T1IF = 0;            // Clear interrupt flag\nIEC0bits.T1IE = 1;            // Enable Timer1 interrupt\nT1CONbits.TON = 1;            // Turn on Timer1\n\n// Interrupt Service Routine\nvoid __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    LATBbits.LATB0 ^= 1;      // Toggle LED\n    IFS0bits.T1IF = 0;        // Clear interrupt flag\n}\n</code></pre>"},{"location":"chapters/chapter-5/#why-this-works","title":"\ud83e\udde0 Why This Works","text":"<ul> <li>The timer counts up to <code>PR1</code> and triggers an interrupt  </li> <li>The ISR toggles the LED and resets the flag  </li> <li>The processor automatically returns to your main loop without losing track</li> </ul> <p>\u2705 You don\u2019t need to manually check the timer \u2014 the interrupt does the work!</p>"},{"location":"chapters/chapter-5/#timing-notes","title":"\u231b Timing Notes","text":"<p>This example assumes: - Fcy = 16 MHz (i.e., 8 MHz instruction cycle) - Prescaler = 1:256 - PR1 = 31250 \u2192 500 ms</p> <p>If your clock speed is different, you'll need to recalculate <code>PR1</code>.</p>"},{"location":"chapters/chapter-5/#section-5-summary-and-best-practices","title":"Section 5: Summary and Best Practices","text":"<p>Timers and interrupts are two of the most powerful features of any microcontroller \u2014 and they often work best together.</p>"},{"location":"chapters/chapter-5/#key-takeaways","title":"\ud83e\udde0 Key Takeaways","text":"<ul> <li>A timer is a hardware counter that increments with time</li> <li>Use <code>PRx</code> to define the period, and <code>TMRx</code> to track the current count</li> <li>Prescalers help slow the timer down to match your time intervals</li> <li>When a timer reaches its period, it can trigger an interrupt</li> <li>The interrupt service routine (ISR) runs automatically, handles the task, and returns</li> <li>Interrupts use the stack to preserve your program state</li> </ul>"},{"location":"chapters/chapter-5/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>\u2714\ufe0f Always clear the interrupt flag (<code>IFSx</code>) inside your ISR</li> <li>\u2714\ufe0f Keep ISRs short and efficient \u2014 don\u2019t do too much inside</li> <li>\u2714\ufe0f Use prescalers to avoid overflow and fit time into a 16-bit period</li> <li>\u2714\ufe0f For more timing flexibility, consider 32-bit timers (pairing TMR2 + TMR3)</li> <li>\u274c Avoid polling timers unless your task is very short or must be ultra-deterministic</li> <li>\u274c Never use <code>delay()</code> loops when timers can do the job more cleanly</li> </ul> <p>Next, we\u2019ll take what we\u2019ve learned about interrupts and apply it to external inputs \u2014 so your microcontroller can respond to real-world events like button presses or signal edges in Chapter 6: External Interrupts &amp; Input Capture.</p>"},{"location":"chapters/chapter-5/#quiz-timers-and-interrupts","title":"\ud83e\udde0 Quiz: Timers and Interrupts","text":"<p>What happens when the timer reaches the value in <code>PR1</code> and interrupts are enabled?</p> <pre><code>T1CONbits.TON = 1;\nPR1 = 31250;\nIEC0bits.T1IE = 1;\n</code></pre> <ol> <li>The timer stops and resets to 0  </li> <li>The CPU halts until the flag is cleared  </li> <li>An interrupt is triggered and the ISR runs  </li> <li>The timer overflows and restarts silently  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>Once the timer reaches <code>PR1</code>, it resets to 0 and triggers an interrupt \u2014 only if interrupts are enabled. This causes the processor to run the ISR (Interrupt Service Routine) associated with that timer. After the ISR completes and the flag is cleared, the main program resumes.</p>"},{"location":"chapters/chapter-5/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code that configures Timer1 to generate an interrupt every 250 milliseconds, assuming a system clock (Fcy) of 16 MHz. In the ISR, toggle an LED connected to PORTB bit 2.</p> Click to show solution <pre><code>// Main setup\nTRISBbits.TRISB2 = 0;           // RB2 as output\nLATBbits.LATB2 = 0;             // Start with LED OFF\n\nT1CONbits.TCKPS = 3;            // Prescaler 1:256\nPR1 = 15625;                    // 250ms at Fcy = 16MHz\nTMR1 = 0;\n\nIFS0bits.T1IF = 0;              // Clear interrupt flag\nIEC0bits.T1IE = 1;              // Enable Timer1 interrupt\nT1CONbits.TON = 1;              // Turn on Timer1\n\n// ISR\nvoid __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    LATBbits.LATB2 ^= 1;        // Toggle LED\n    IFS0bits.T1IF = 0;          // Clear interrupt flag\n}\n</code></pre>"},{"location":"chapters/chapter-6/","title":"Chapter 6: External Interrupts &amp; Input Capture","text":""},{"location":"chapters/chapter-6/#section-1-what-are-external-interrupts","title":"Section 1: What Are External Interrupts?","text":"<p>External interrupts allow your microcontroller to react immediately to changes on specific input pins, such as when a button is pressed, a sensor detects motion, or a digital signal changes state.</p>"},{"location":"chapters/chapter-6/#how-they-work","title":"\ud83e\udde0 How They Work","text":"<p>External interrupts are triggered by electrical transitions on dedicated interrupt pins:</p> <ul> <li>Rising edge \u2192 when the signal goes from LOW (0) to HIGH (1)</li> <li>Falling edge \u2192 when the signal goes from HIGH (1) to LOW (0)</li> <li>Some systems allow both edges to trigger an interrupt</li> </ul> <p>When such a change is detected, the microcontroller pauses its current task, runs a specific function called an Interrupt Service Routine (ISR), then returns to what it was doing \u2014 all within a few cycles.</p>"},{"location":"chapters/chapter-6/#hardware-lines-intx","title":"\ud83d\udd0c Hardware Lines: INTx","text":"<p>The PIC24 provides dedicated external interrupt inputs: - <code>INT0</code> is fixed to a specific pin and always uses rising edge detection - <code>INT1</code>, <code>INT2</code>, etc. are configurable: you can choose rising or falling edge - Each has its own flag (<code>IFSx</code>), enable bit (<code>IECx</code>), and priority level (<code>IPCx</code>)</p>"},{"location":"chapters/chapter-6/#common-use-cases","title":"\u2705 Common Use Cases","text":"<ul> <li>Detecting a button press (toggle an LED, start/stop a timer)</li> <li>Triggering logic when an object breaks a beam sensor</li> <li>Starting an event when a signal changes state</li> <li>Reading a pulse train from another digital system</li> </ul> <p>\u23f1\ufe0f External interrupts allow your microcontroller to be responsive without constant polling \u2014 saving power and processing time.</p> <p>In the next section, we\u2019ll show how to configure these interrupts on the PIC24 and respond to real-world input like a button press.</p>"},{"location":"chapters/chapter-6/#section-2-configuring-external-interrupts-intx","title":"Section 2: Configuring External Interrupts (INTx)","text":"<p>To use an external interrupt on the PIC24, you'll need to configure three main things:</p> <ol> <li>Edge sensitivity \u2014 rising or falling</li> <li>Enable the interrupt</li> <li>Clear the interrupt flag in your ISR</li> </ol>"},{"location":"chapters/chapter-6/#basic-setup-int1","title":"\ud83d\udd39 Basic Setup: INT1","text":"<p>Here\u2019s how to configure INT1 to trigger on a falling edge (e.g. button press):</p> <pre><code>TRISBbits.TRISB7 = 1;              // Set RB7 as input\nINTCON2bits.INT1EP = 1;            // 1 = falling edge, 0 = rising edge\n\nIFS1bits.INT1IF = 0;               // Clear interrupt flag\nIEC1bits.INT1IE = 1;               // Enable INT1 interrupt\n</code></pre> <p>And the corresponding ISR:</p> <pre><code>void __attribute__((__interrupt__, auto_psv)) _INT1Interrupt(void) {\n    IFS1bits.INT1IF = 0;           // Clear the interrupt flag\n    LATBbits.LATB0 = 1;           // Toggle LED (for example)\n}\n</code></pre>"},{"location":"chapters/chapter-6/#register-summary-for-int1","title":"\u2699\ufe0f Register Summary for INT1","text":"Register Purpose <code>INTCON2bits.INT1EP</code> 1 = falling edge, 0 = rising edge <code>IEC1bits.INT1IE</code> Enable bit for INT1 <code>IFS1bits.INT1IF</code> Interrupt flag for INT1 <code>IPC5bits.INT1IP</code> Priority level (optional)"},{"location":"chapters/chapter-6/#example-toggle-led-on-button-press","title":"\ud83e\uddea Example: Toggle LED on Button Press","text":"<p>You can connect a button between <code>RB7</code> and GND. When pressed, the line goes LOW, triggering the falling edge interrupt. The ISR toggles an LED on <code>RB0</code>.</p> <p>\ud83d\udcdd Remember to include a pull-up resistor (internal or external) to hold <code>RB7</code> HIGH when the button is not pressed.</p>"},{"location":"chapters/chapter-6/#quick-note-pull-up-resistors","title":"\ud83d\udd0c Quick Note: Pull-Up Resistors","text":"<p>When using an external interrupt triggered by a button, the pin needs to have a known voltage level when the button is not pressed. Otherwise, it may float unpredictably and trigger false interrupts.</p> <p>A pull-up resistor holds the line HIGH by default. When the button is pressed, it pulls the line LOW \u2014 creating a clean falling edge.</p> <p>You can use: - An external pull-up resistor (e.g., 10k\u03a9 to Vdd), or - Enable the internal pull-up (on some PIC24 devices via <code>CNPUx</code> register)</p> <p>\u2705 This ensures your interrupt only fires when the button is intentionally pressed.</p> <p>Next, we\u2019ll explore Input Capture, a different kind of input interrupt used for measuring timing of digital signals.</p>"},{"location":"chapters/chapter-6/#section-3-what-is-input-capture","title":"Section 3: What Is Input Capture?","text":"<p>While external interrupts help detect when an event occurs, input capture helps you measure how long something took or when exactly it happened \u2014 with precision.</p> <p>Input capture is used to record the exact timer value at the moment an external signal changes. This allows you to measure things like:</p> <ul> <li>The time between two button presses</li> <li>The frequency of a square wave</li> <li>The pulse width of a PWM signal</li> </ul>"},{"location":"chapters/chapter-6/#why-use-input-capture","title":"\ud83e\udde0 Why Use Input Capture?","text":"<p>Input capture modules are tightly linked to timers. They \"capture\" the current timer count and store it in a buffer the moment a specified edge occurs.</p> <p>This enables precise time stamping without needing to poll the input manually.</p>"},{"location":"chapters/chapter-6/#key-use-cases","title":"\ud83d\udce6 Key Use Cases","text":"<ul> <li>Pulse width measurement (how long a signal stayed high or low)</li> <li>Frequency detection (time between rising edges)</li> <li>Reaction timing (time between stimulus and response)</li> <li>Detecting variable pulse signals like servo control or ultrasonic sensors</li> </ul>"},{"location":"chapters/chapter-6/#input-capture-vs-external-interrupts","title":"\ud83d\udd01 Input Capture vs External Interrupts","text":"Feature External Interrupt Input Capture Purpose Trigger code Record time of event Edge Response ISR runs on edge Timer value recorded Useful For Logic control Precision timing CPU Involvement Immediate ISR Minimal \u2014 buffered <p>\ud83c\udfaf Use input capture when you're more interested in when something happened than what should happen immediately.</p> <p>In the next section, we\u2019ll walk through how to configure and use input capture modules on the PIC24.</p>"},{"location":"chapters/chapter-6/#section-4-setting-up-input-capture-icx","title":"Section 4: Setting Up Input Capture (ICx)","text":"<p>To use Input Capture on the PIC24, you'll configure one of the ICx modules (e.g., IC1, IC2) to record the timer value when a digital signal changes on a designated pin.</p> <p>The capture value is automatically placed into a buffer, which you can read later in software or inside an ISR.</p>"},{"location":"chapters/chapter-6/#basic-configuration-steps","title":"\ud83d\udd39 Basic Configuration Steps","text":"<ol> <li>Configure the pin as an input</li> <li>Select the timer source (usually TMR2 or TMR3)</li> <li>Set the edge mode (rising, falling, or every edge)</li> <li>Enable interrupts (optional, but common)</li> <li>Read the captured value from the ICx buffer</li> </ol>"},{"location":"chapters/chapter-6/#code-example-measure-time-between-pulses","title":"\ud83d\udee0\ufe0f Code Example: Measure Time Between Pulses","text":"<pre><code>// Setup for IC1 using Timer2\nIC1CON = 0\nT2CON = 0                         //Set the configuration to 0 as good practice\nTRISBbits.TRISB2 = 1;             // Set RB2 (IC1 input) as input\n\nT2CONbits.TCKPS = 2;              // Prescaler 1:64\nTMR2 = 0;\nPR2 = 0xFFFF;\nT2CONbits.TON = 1;                // Turn on Timer2\n\nIC1CONbits.ICM = 1;               // Capture on every rising edge\nIC1CONbits.ICTMR = 1;            // Use Timer2 as time base\nIC1CONbits.ICI = 0;              // Interrupt on every capture\nIC1CONbits.ON = 1;               // Enable Input Capture\n\nIFS0bits.IC1IF = 0;              // Clear interrupt flag\nIEC0bits.IC1IE = 1;              // Enable interrupt\n\n// ISR to read captured time\nvoid __attribute__((__interrupt__, auto_psv)) _IC1Interrupt(void) {\n    IFS0bits.IC1IF = 0;          // Clear interrupt flag\n    uint16_t time = IC1BUF;      // Read captured timer value\n}\n</code></pre>"},{"location":"chapters/chapter-6/#edge-detection-options","title":"\ud83d\udd04 Edge Detection Options","text":"Mode Value Trigger Condition 1 Every rising edge 2 Every falling edge 3 Every edge (rising + falling) 0 Module disabled <p>Set using: <code>ICxCONbits.ICM = value;</code></p> <p>\ud83d\udcdd You can change the capture mode on the fly if you want to capture both rising and falling edges in sequence.</p> <p>In the next section, we\u2019ll summarize the difference between external interrupts and input capture, and wrap up with tips and use cases.</p>"},{"location":"chapters/chapter-6/#section-5-summary-and-best-practices","title":"Section 5: Summary and Best Practices","text":"<p>External interrupts and input capture give your microcontroller the ability to react to real-world events and measure their timing precisely \u2014 both essential tools in embedded systems.</p>"},{"location":"chapters/chapter-6/#key-takeaways","title":"\ud83e\udde0 Key Takeaways","text":"<ul> <li>External Interrupts (INTx):</li> <li>Trigger an ISR when a pin changes (rising/falling edge)</li> <li>Great for reacting to button presses or logic events</li> <li> <p>Must clear the interrupt flag inside the ISR</p> </li> <li> <p>Input Capture (ICx):</p> </li> <li>Records the timer value when a pin changes</li> <li>Perfect for measuring pulse width, frequency, or time between events</li> <li> <p>Doesn\u2019t require logic inside the ISR (just read <code>ICxBUF</code>)</p> </li> <li> <p>Both can be configured for rising, falling, or both edges</p> </li> </ul>"},{"location":"chapters/chapter-6/#best-practices","title":"\u2705 Best Practices","text":"<ul> <li>\u2714\ufe0f Use pull-up or pull-down resistors to ensure clean digital signals</li> <li>\u2714\ufe0f Debounce buttons (in software or hardware) to avoid multiple triggers</li> <li>\u2714\ufe0f Clear flags inside the ISR: <code>IFSxbits.INTxIF</code> or <code>ICxIF</code></li> <li>\u2714\ufe0f Use input capture when timing is more important than triggering behavior</li> <li>\u274c Don\u2019t read <code>ICxBUF</code> unless <code>ICxIF</code> is set \u2014 you could get junk data</li> </ul>"},{"location":"chapters/chapter-6/#-","title":"---","text":""},{"location":"chapters/chapter-6/#note-peripheral-pin-mapping-pps","title":"\ud83d\udee0\ufe0f Note: Peripheral Pin Mapping (PPS)","text":"<p>On PIC24 devices with remappable pins, you must use Peripheral Pin Select (PPS) to assign Input Capture (ICx), Output Compare (OCx), UART, and other modules to specific physical pins.</p> <p>For example, to map IC1 to RP7 (e.g., RB7):</p> <pre><code>__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPINR7bits.IC1R = 7;                      // IC1 input = RP7\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n</code></pre> <p>\u26a0\ufe0f Skipping this step may cause ICx or OCx modules to appear non-functional.</p> <p>Always refer to your microcontroller\u2019s datasheet or family reference manual to find valid RPx mappings for your device.</p> <p>Next, we\u2019ll explore how to generate waveforms and control power using output compare and PWM in Chapter 7!</p>"},{"location":"chapters/chapter-6/#quiz-external-interrupts-input-capture","title":"\ud83e\udde0 Quiz: External Interrupts &amp; Input Capture","text":"<p>What does the input capture module do when it detects a rising edge on its input pin?</p> <pre><code>IC1CONbits.ICM = 1;   // Capture on rising edge\n</code></pre> <ol> <li>Immediately jumps to an interrupt  </li> <li>Saves the value of PRx  </li> <li>Saves the value of TMRx into IC1BUF  </li> <li>Resets the timer to zero  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>The input capture module stores the current value of the timer (usually TMR2 or TMR3) into <code>IC1BUF</code> when the rising edge occurs. This lets you determine exactly when the signal changed \u2014 great for measuring duration, frequency, or spacing between pulses.</p>"},{"location":"chapters/chapter-6/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code that configures Input Capture 1 (IC1) to capture the time of every falling edge on pin RP7, using Timer2 as the time base. Assume you\u2019ve already configured <code>TMR2</code> with an appropriate prescaler.</p> Click to show solution <pre><code>// Set up pin mapping: IC1 on RP7 (RB7)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPINR7bits.IC1R = 7;                      // Map IC1 input to RP7\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure IC1\nTRISBbits.TRISB7 = 1;           // RB7 as input\nIC1CONbits.ICTMR = 1;           // Use Timer2 as time base\nIC1CONbits.ICM = 2;             // Capture on falling edge\nIC1CONbits.ICI = 0;             // Interrupt on every event\nIC1CONbits.ON = 1;              // Turn on IC1\n\nIFS0bits.IC1IF = 0;             // Clear interrupt flag\nIEC0bits.IC1IE = 1;             // Enable interrupt\n\n// IC1 ISR\nvoid __attribute__((__interrupt__, auto_psv)) _IC1Interrupt(void) {\n    uint16_t timeStamp = IC1BUF;   // Read captured time\n    IFS0bits.IC1IF = 0;            // Clear flag\n}\n</code></pre>"},{"location":"chapters/chapter-7/","title":"Chapter 7: Output Compare &amp; PWM","text":""},{"location":"chapters/chapter-7/#section-1-what-is-output-compare","title":"Section 1: What Is Output Compare?","text":"<p>The Output Compare (OCx) module on the PIC24 allows you to generate a digital output signal based on a timer match event.</p> <p>At a high level, you configure a timer (like <code>TMR2</code>), and when the timer reaches a specific value stored in the <code>OCxR</code> or <code>OCxRS</code> register, the output pin toggles, sets, clears, or pulses depending on your chosen mode.</p>"},{"location":"chapters/chapter-7/#what-its-used-for","title":"\ud83e\udde0 What It's Used For","text":"<ul> <li>Generate precise timing pulses</li> <li>Toggle an output pin without software involvement</li> <li>Create PWM signals by controlling pulse width via timer values</li> </ul>"},{"location":"chapters/chapter-7/#how-it-works","title":"\ud83d\udd01 How It Works","text":"<ol> <li>Timer (e.g., <code>TMR2</code>) counts up</li> <li>When <code>TMR2</code> matches <code>OCxR</code>, the output pin changes</li> <li>In PWM mode, this continues as long as the timer runs</li> </ol> <p>This all happens in hardware, without using up CPU cycles.</p>"},{"location":"chapters/chapter-7/#core-registers-example-oc1","title":"\ud83e\uddea Core Registers (Example: OC1)","text":"Register Role <code>OC1R</code> Compare value \u2014 when output changes initially <code>OC1RS</code> Secondary compare \u2014 used in PWM mode <code>OC1CON</code> Control register for mode selection and timer link <code>OC1IF</code> Interrupt flag (optional use) <p>\ud83d\udd17 Output Compare modules are tightly tied to timers \u2014 most often TMR2 or TMR3 \u2014 because these timers are 16-bit, high-resolution, and designed for timing tasks like PWM generation. Timers like TMR1 are typically reserved for timekeeping or general interrupts, while TMR2/TMR3 are better suited for waveform generation.</p> <p>In the next section, we\u2019ll step back briefly and explain what Pulse Width Modulation (PWM) is \u2014 since that\u2019s the most popular use case for Output Compare modules.</p>"},{"location":"chapters/chapter-7/#section-2-what-is-pwm-pulse-width-modulation","title":"Section 2: What Is PWM (Pulse Width Modulation)?","text":"<p>Pulse Width Modulation (PWM) is a technique used to simulate analog control using a digital signal that rapidly switches between HIGH and LOW.</p> <p>Instead of sending a constant voltage, PWM sends pulses \u2014 and by controlling how long the signal stays HIGH during each cycle, you can control the average power delivered.</p>"},{"location":"chapters/chapter-7/#key-concepts","title":"\ud83e\udde0 Key Concepts","text":"<ul> <li>Period: The total duration of one complete on/off cycle</li> <li>Duty cycle: The percentage of the period that the signal is HIGH</li> <li>100% duty = always ON</li> <li>0% duty = always OFF</li> <li>50% duty = ON for half the time, OFF for the other half</li> <li>Frequency: How many PWM cycles occur per second (Hz)</li> </ul>"},{"location":"chapters/chapter-7/#why-its-useful","title":"\ud83d\udd26 Why It's Useful","text":"<p>PWM allows you to: - Dim an LED by adjusting brightness - Control motor speed or servo position - Modulate audio signals - Generate analog-like control signals without needing a dedicated Digital-to-Analog Converter (DAC) \u2014 the PWM duty cycle controls the average voltage instead.</p> <p>All of this is done with just one digital output pin.</p>"},{"location":"chapters/chapter-7/#example-duty-cycles","title":"\ud83d\udcc9 Example Duty Cycles","text":"Duty Cycle Description 0% Always OFF 25% Brief ON, mostly OFF 50% Equal ON and OFF 75% Mostly ON 100% Always ON <p>\ud83c\udf9b\ufe0f Adjusting duty cycle lets you control how much \"power\" a device receives over time.</p> <p>In the next section, we\u2019ll connect this concept to Output Compare and show how to generate PWM signals in hardware using the <code>OCx</code> module.</p>"},{"location":"chapters/chapter-7/#section-3-generating-pwm-with-output-compare","title":"Section 3: Generating PWM with Output Compare","text":"<p>Now that you understand how PWM works, let's generate it in hardware using the Output Compare (OCx) module on the PIC24.</p> <p>The OCx module can be configured to output a PWM signal using a timer (typically <code>TMR2</code> or <code>TMR3</code>) as a time base.</p>"},{"location":"chapters/chapter-7/#configuration-overview","title":"\ud83d\udd27 Configuration Overview","text":"<p>To generate PWM with <code>OCx</code>:</p> <ol> <li>Set up a timer (<code>TMR2</code> or <code>TMR3</code>) with the desired period</li> <li>Set <code>OCxR</code> to define when the pulse goes HIGH</li> <li>Set <code>OCxRS</code> to define when the pulse goes LOW</li> <li>Configure <code>OCxCON</code> to enable PWM mode</li> <li>Map the OCx output to a physical pin (using PPS if required)</li> </ol>"},{"location":"chapters/chapter-7/#example-50-duty-cycle-on-oc1-using-tmr2","title":"\ud83d\udee0\ufe0f Example: 50% Duty Cycle on OC1 using TMR2","text":"<pre><code>//Setting configuration so we don't keep any unwanted specification from prior, good practice\nT2CON = 0\nOC1CON = 0                 \n\n// Map OC1 output to RP9 (e.g., RB9)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 18;                      // RP9 = OC1\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure OC1 for PWM\nOC1CONbits.OCM = 0b110;           // PWM mode, fault pin disabled\nOC1CONbits.OCTSEL = 0;            // Use Timer2\nOC1RS = 25000;                    // 50% duty cycle (pulse ends here)\nOC1R = 25000;                     // Initial pulse start point\nOC1CONbits.ON = 1;                // Enable Output Compare\n\n// Configure Timer2 for PWM period\nT2CONbits.TCKPS = 0b010;          // Prescaler 1:64\nPR2 = 49999;                      // Sets PWM period\nTMR2 = 0;\nT2CONbits.TON = 1;                // Start Timer2\n</code></pre>"},{"location":"chapters/chapter-7/#notes-on-values","title":"\ud83d\udccf Notes on Values","text":"<ul> <li><code>PR2</code> sets the period of the PWM</li> <li><code>OC1RS</code> sets the duty cycle (pulse width)</li> <li>A value of <code>OC1RS = PR2 / 2</code> gives 50% duty</li> <li>You can change <code>OC1RS</code> on the fly to adjust brightness/speed/etc.</li> </ul> <p>\ud83e\udde0 Think of the timer as the metronome and OCx as the switch that turns the output pin ON and OFF with precise timing.</p> <p>Next, we\u2019ll compare this hardware PWM with the software-based version \u2014 and show why hardware is often the better choice.</p>"},{"location":"chapters/chapter-7/#section-4-software-vs-hardware-pwm","title":"Section 4: Software vs Hardware PWM","text":"<p>There are two ways to generate a PWM signal on a microcontroller:</p> <ol> <li>Software PWM \u2014 manually toggle a pin inside a loop</li> <li>Hardware PWM \u2014 use the Output Compare (OCx) module linked to a timer</li> </ol> <p>Let\u2019s compare the two approaches:</p>"},{"location":"chapters/chapter-7/#software-pwm","title":"\ud83d\udda5\ufe0f Software PWM","text":"<p>In software PWM, you write code like this:</p> <pre><code>while (1) {\n    LATBbits.LATB1 = 1;      // Set HIGH\n    delay_us(500);           // ON time\n    LATBbits.LATB1 = 0;      // Set LOW\n    delay_us(500);           // OFF time\n}\n</code></pre> <p>This works, but it: - Uses the CPU 100% of the time - Is affected by interrupts or timing jitter - Doesn\u2019t scale well (you can\u2019t drive many PWM channels at once)</p>"},{"location":"chapters/chapter-7/#hardware-pwm-with-output-compare","title":"\u2699\ufe0f Hardware PWM (with Output Compare)","text":"<p>In hardware PWM, once you configure the <code>OCx</code> module, the PWM output runs automatically in the background.</p> <p>Benefits: - \ud83d\udd04 Doesn't use CPU cycles - \ud83d\udd0d Precise timing tied to hardware clock - \ud83d\udca1 Reliable frequency and duty cycle - \ud83d\udcc8 Scales well (multiple OCx channels)</p> <p>\ud83e\udde0 Hardware PWM is like a metronome: once set, it keeps time perfectly \u2014 while your code is free to focus on other tasks.</p> <p>Unless you need something very custom, hardware PWM is always the better choice when available.</p>"},{"location":"chapters/chapter-7/#comparison-table","title":"\u2696\ufe0f Comparison Table","text":"Feature Software PWM Hardware PWM (OCx) CPU Usage High (manual toggling) Minimal (runs independently) Timing Accuracy Affected by code &amp; delays Very accurate (timer-based) Interrupt Sensitivity High Low Scalability Poor (one pin at a time) Excellent (multiple OCx modules) Power Efficiency Low High <p>\u2705 Use hardware PWM whenever precise, low-overhead control is needed.</p> <p>Next, we\u2019ll wrap up with common applications and best practices.</p>"},{"location":"chapters/chapter-7/#section-5-summary-and-use-cases","title":"Section 5: Summary and Use Cases","text":"<p>The Output Compare (OCx) module is one of the most powerful peripherals on the PIC24 \u2014 especially when used to generate PWM signals.</p> <p>Paired with a timer, it allows you to produce high-precision digital waveforms that simulate analog control \u2014 without using CPU time.</p>"},{"location":"chapters/chapter-7/#key-takeaways","title":"\ud83d\udd01 Key Takeaways","text":"<ul> <li>Output Compare compares a timer value to a register (<code>OCxR</code>/<code>OCxRS</code>) and toggles an output accordingly.</li> <li>PWM (Pulse Width Modulation) controls average power by varying ON/OFF times.</li> <li>Hardware PWM is far superior to software-based PWM in timing accuracy, scalability, and CPU usage.</li> <li>You can remap OCx to various output pins using Peripheral Pin Select (PPS).</li> </ul>"},{"location":"chapters/chapter-7/#real-world-applications","title":"\ud83d\udca1 Real-World Applications","text":"Application How PWM Helps LED Dimming Adjust brightness by changing duty cycle Servo Control Send precise pulse widths (1\u20132 ms range) Motor Speed Control Modulate voltage applied to motor coils Audio Generation Output tones or waveforms digitally Power Regulation Smooth delivery of variable DC voltage <p>\ud83d\udd27 PWM is everywhere \u2014 from drone motors to smart lightbulbs.</p> <p>Next up, we\u2019ll explore communication and peripheral modules, including UART, SPI, I2C, and ADCs!</p>"},{"location":"chapters/chapter-7/#quiz-understanding-pwm-behavior","title":"\ud83e\udde0 Quiz: Understanding PWM Behavior","text":"<p>What happens if the value in <code>OC1RS</code> is set equal to <code>PR2</code> when generating PWM using Timer2?</p> <pre><code>PR2 = 40000;\nOC1RS = 40000;\n</code></pre> <ol> <li>The PWM signal will always be HIGH  </li> <li>The PWM signal will be 50% duty cycle  </li> <li>The PWM signal will always be LOW  </li> <li>The PWM signal will toggle randomly  </li> </ol> Show Answer <p>The correct answer is A.</p> <p>If <code>OC1RS</code> equals <code>PR2</code>, the pulse stays HIGH for the full duration of the PWM period \u2014 resulting in 100% duty cycle. The output never drops LOW during the cycle.</p>"},{"location":"chapters/chapter-7/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code to configure OC1 to generate a 75% duty cycle PWM signal on pin RP9, using Timer2 and a period of 20 ms (standard servo PWM timing). Assume a system clock of 16 MHz.</p> Click to show solution <pre><code>// Configure Timer2 for 20 ms period\nT2CONbits.TCKPS = 3;              // Prescaler 1:256\nPR2 = 1250;                       // 20 ms at 16 MHz / 256\n\nTMR2 = 0;\nT2CONbits.TON = 1;                // Start Timer2\n\n// Map OC1 output to RP9 (RB9)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 18;                      // RP9 = OC1\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure OC1 for PWM mode\nOC1CONbits.OCM = 0b110;           // PWM mode, no fault pin\nOC1CONbits.OCTSEL = 0;            // Use Timer2\n\nOC1RS = 937;                      // 75% duty cycle (0.75 \u00d7 1250)\nOC1R = 937;                       // Initial compare value\nOC1CONbits.ON = 1;                // Enable Output Compare\n</code></pre>"},{"location":"chapters/chapter-8/","title":"Chapter 8: Communication &amp; Peripherals","text":""},{"location":"chapters/chapter-8/#section-1-why-communication-matters","title":"Section 1: Why Communication Matters","text":"<p>Microcontrollers are powerful, but they rarely operate in isolation. Most embedded systems need to communicate with other devices, whether it's a:</p> <ul> <li>Computer (e.g., serial terminal)</li> <li>Sensor (e.g., accelerometer, temperature probe)</li> <li>Display (e.g., OLED or LCD)</li> <li>Another microcontroller or peripheral</li> </ul> <p>To accomplish this, microcontrollers use a variety of serial communication protocols that allow them to send and receive data efficiently.</p>"},{"location":"chapters/chapter-8/#serial-vs-parallel-communication","title":"\ud83e\udde0 Serial vs Parallel Communication","text":"Type Description Example Use Parallel Multiple bits sent simultaneously (wider) Older systems, LCDs Serial Bits sent one at a time over fewer wires UART, SPI, I2C <p>\ud83d\udd0e Parallel is faster in theory, but requires many I/O pins and wires. Serial is simpler, more scalable, and dominates in modern designs.</p>"},{"location":"chapters/chapter-8/#why-we-use-uart-spi-and-i2c","title":"\ud83d\udce6 Why We Use UART, SPI, and I2C","text":"<p>These three protocols are the most common in microcontroller systems:</p> Protocol Wires Use Case Speed UART 2 PC communication, debugging Moderate (115200+ bps) SPI 4 High-speed peripherals, sensors Fast (MHz+) I2C 2 Multi-device, low-speed communication Moderate (~100k\u2013400kHz) <p>Each has tradeoffs \u2014 some are better for speed, some for simplicity, and some for connecting many devices.</p>"},{"location":"chapters/chapter-8/#tradeoffs-limitations","title":"\u26a0\ufe0f Tradeoffs &amp; Limitations","text":"Protocol Limitations UART Only supports one-to-one communication, requires matching baud rates SPI Needs more wires, no built-in addressing, typically one master only I2C Slower than SPI, more complex protocol, can suffer from bus contention <p>\u2696\ufe0f Choosing the right protocol depends on the number of devices, speed requirements, and system complexity.</p> <p>In the next sections, we'll explore each protocol in detail, how to configure it on the PIC24, and common use cases.</p>"},{"location":"chapters/chapter-8/#section-2-uart-universal-asynchronous-receivertransmitter","title":"Section 2: UART (Universal Asynchronous Receiver/Transmitter)","text":"<p>UART is a simple serial communication protocol that sends and receives data asynchronously \u2014 meaning it doesn\u2019t need a shared clock between devices.</p> <p>Instead, both devices agree on a baud rate (bits per second), like <code>9600</code>, <code>38400</code>, or <code>115200</code>, and communicate using two lines:</p> <ul> <li>TX (transmit)</li> <li>RX (receive)</li> </ul>"},{"location":"chapters/chapter-8/#uart-frame-format","title":"\ud83e\udde0 UART Frame Format","text":"<p>Each UART message is made up of: - 1 start bit - 8 data bits (usually) - Optional parity bit - 1 stop bit</p> <p>So sending 1 byte over UART actually sends at least 10 bits.</p> <p>\u23f3 Timing is critical \u2014 both devices must use the same baud rate to avoid garbled data.</p>"},{"location":"chapters/chapter-8/#configuring-uart-on-the-pic24","title":"\u2699\ufe0f Configuring UART on the PIC24","text":"<p>UART modules are named <code>U1MODE</code>, <code>U1STA</code>, etc. for UART1. You\u2019ll also need to map TX/RX pins using PPS.</p> <p>Example: Echo received characters using UART1 at 9600 baud.</p> <pre><code>// Configure pins (TX = RP10, RX = RP8)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR5bits.RP10R = 3;                      // U1TX on RP10\nRPINR18bits.U1RXR = 8;                    // U1RX on RP8\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// UART1 Settings\nU1MODEbits.BRGH = 0;                      // Standard speed mode\nU1BRG = 103;                              // Baud = 9600 (for 16MHz clock)\nU1MODEbits.UARTEN = 1;                    // Enable UART\nU1STAbits.UTXEN = 1;                      // Enable TX\n\n// Echo loop\nwhile (1) {\n    if (U1STAbits.URXDA) {               // Data available?\n        char c = U1RXREG;                // Read char\n        while (!U1STAbits.TRMT);         // Wait if TX is busy\n        U1TXREG = c;                     // Echo back\n    }\n}\n</code></pre>"},{"location":"chapters/chapter-8/#typical-use-cases","title":"\ud83e\uddea Typical Use Cases","text":"<ul> <li>Serial terminals (via USB-to-UART converters)</li> <li>Debugging (print variables over UART)</li> <li>Interfacing with GPS, Bluetooth, or WiFi modules</li> </ul> <p>\ud83d\udee0\ufe0f UART is often your first line of communication and debugging when bringing up a new project.</p> <p>Up next: we\u2019ll cover SPI, a faster protocol with full-duplex communication.</p>"},{"location":"chapters/chapter-8/#quiz-uart-communication","title":"\ud83e\udde0 Quiz: UART Communication","text":"<p>Which of the following must be true for two devices to successfully communicate over UART?</p> <ol> <li>They must share the same clock signal  </li> <li>They must have the same pin mappings  </li> <li>They must use the same baud rate  </li> <li>They must use a master-slave architecture  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>UART is asynchronous \u2014 there is no shared clock. However, both devices must be configured to use the same baud rate, or else the timing will be mismatched and the data will be corrupted.</p>"},{"location":"chapters/chapter-8/#prompt-practice","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code to configure UART1 to transmit the string <code>\"Hello\"</code> continuously at 115200 baud, using TX on RP9.</p> Click to show solution <pre><code>// PPS Mapping for UART1 TX\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 3;                       // U1TX on RP9\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// UART1 Settings\nU1MODEbits.BRGH = 0;                      // Standard speed\nU1BRG = 8;                                // 115200 baud @ 16MHz\nU1MODEbits.UARTEN = 1;                    // Enable UART\nU1STAbits.UTXEN = 1;                      // Enable TX\n\n// Transmit \"Hello\" forever\nwhile (1) {\n    const char *msg = \"Hello\\r\\n\";\n    for (int i = 0; msg[i] != '\\0'; i++) {\n        while (!U1STAbits.TRMT);          // Wait if TX is busy\n        U1TXREG = msg[i];\n    }\n    __delay_ms(1000);                     // Delay 1s between messages\n}\n</code></pre>"},{"location":"chapters/chapter-8/#section-3-spi-serial-peripheral-interface","title":"Section 3: SPI (Serial Peripheral Interface)","text":"<p>SPI is a high-speed, full-duplex communication protocol designed for fast data exchange between a master and one or more slaves.</p> <p>Unlike UART, SPI uses a shared clock line, which enables tight synchronization between devices.</p>"},{"location":"chapters/chapter-8/#spi-signals","title":"\ud83d\udd0c SPI Signals","text":"Line Name Direction (Master \u2192 Slave) SCK Clock \u2b05 Master provides clock MOSI Data \u2b05 Master Out, Slave In MISO Data \u2b05 Master In, Slave Out SS Select \u2b05 Active LOW (one per slave) <p>SPI is faster than UART or I2C and supports streaming data in both directions at once.</p>"},{"location":"chapters/chapter-8/#how-spi-works","title":"\ud83e\udde0 How SPI Works","text":"<ul> <li>The master controls the clock (SCK)</li> <li>Data is shifted out bit by bit on MOSI/MISO</li> <li>The slave select (SS) line tells which device is active</li> <li>Most devices use 8-bit or 16-bit transfers</li> </ul>"},{"location":"chapters/chapter-8/#configuring-spi-on-pic24-as-master","title":"\u2699\ufe0f Configuring SPI on PIC24 (as Master)","text":"<pre><code>// Set up SPI1 in Master mode (8-bit, clock = Fosc/16)\nSPI1CON = 0;\nSPI1CON1bits.MSTEN = 1;        // Master mode\nSPI1CON1bits.MODE16 = 0;       // 8-bit mode\nSPI1CON1bits.CKE = 1;          // Clock edge\nSPI1CON1bits.SMP = 0;          // Input sampled in middle\nSPI1CON1bits.SPRE = 0b110;     // Secondary prescaler 2:1\nSPI1CON1bits.PPRE = 0b10;      // Primary prescaler 4:1\nSPI1STATbits.SPIEN = 1;        // Enable SPI\n\n// Transmit one byte (0xAA)\nSPI1BUF = 0xAA;\nwhile (!SPI1STATbits.SPIRBF);  // Wait until received\nuint8_t received = SPI1BUF;    // Read incoming byte\n</code></pre>"},{"location":"chapters/chapter-8/#use-cases","title":"\ud83e\uddea Use Cases","text":"<ul> <li>SD cards, flash memory</li> <li>OLED displays</li> <li>High-speed sensors (accelerometers, gyros)</li> <li>DACs or other peripherals needing fast streaming</li> </ul> <p>\ud83d\udd27 SPI is great for speed and low-latency, but requires more pins and doesn\u2019t support automatic addressing like I2C.</p> <p>Next up: we\u2019ll cover I2C, ideal for connecting many devices with fewer wires.</p>"},{"location":"chapters/chapter-8/#quiz-spi-basics","title":"\ud83e\udde0 Quiz: SPI Basics","text":"<p>Which of the following is NOT true about the SPI protocol?</p> <ol> <li>It uses a clock signal shared by the master  </li> <li>It can transfer and receive data simultaneously  </li> <li>It requires only one wire for communication  </li> <li>It allows for fast data exchange with peripherals  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>SPI uses at least 4 wires: SCK, MOSI, MISO, and SS. While it's fast and full-duplex, it\u2019s not a single-wire protocol like some asynchronous options.</p>"},{"location":"chapters/chapter-8/#prompt-practice_1","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code to configure SPI1 on the PIC24 to operate in 8-bit master mode, then send the value <code>0x55</code> and store the received byte.</p> Click to show solution <pre><code>// SPI1 Master Mode Setup\nSPI1CON1bits.MSTEN = 1;        // Master mode\nSPI1CON1bits.MODE16 = 0;       // 8-bit mode\nSPI1CON1bits.CKE = 1;          // Data changes on active-to-idle clock edge\nSPI1CON1bits.SMP = 0;          // Input sampled in middle of data output\nSPI1CON1bits.SPRE = 0b110;     // Secondary prescaler 2:1\nSPI1CON1bits.PPRE = 0b10;      // Primary prescaler 4:1\nSPI1STATbits.SPIEN = 1;        // Enable SPI\n\n// Transmit 0x55 and receive byte\nSPI1BUF = 0x55;\nwhile (!SPI1STATbits.SPIRBF);  // Wait for transmission complete\nuint8_t received = SPI1BUF;    // Read received byte\n</code></pre>"},{"location":"chapters/chapter-8/#section-4-i2c-inter-integrated-circuit","title":"Section 4: I2C (Inter-Integrated Circuit)","text":"<p>I2C is a synchronous, serial protocol designed for communication between multiple devices using just two wires:</p> <ul> <li>SCL: Clock line</li> <li>SDA: Data line</li> </ul> <p>One device acts as the master (controls the clock), while others act as slaves.</p>"},{"location":"chapters/chapter-8/#i2c-addressing","title":"\ud83e\udde0 I2C Addressing","text":"<p>Each slave on the bus has a 7-bit or 10-bit address. The master begins communication by sending:</p> <ul> <li>A START condition</li> <li>The address of the device it wants to talk to</li> <li>A Read/Write bit</li> <li>A slave responds with an ACK or NACK</li> </ul>"},{"location":"chapters/chapter-8/#typical-use-cases_1","title":"\ud83e\uddea Typical Use Cases","text":"<ul> <li>Reading data from sensors (temp, accelerometer, etc.)</li> <li>Communicating with I2C memory (EEPROMs)</li> <li>Interfacing with real-time clocks or displays</li> </ul> <p>\ud83d\udcda I2C is slower than SPI but allows many devices to share just two pins, saving valuable I/O space.</p>"},{"location":"chapters/chapter-8/#i2c-example-reading-a-byte-from-a-slave-pseudo-code","title":"\u2699\ufe0f I2C Example: Reading a Byte from a Slave (Pseudo-code)","text":"<pre><code>I2C1CON = 0;\nI2C1CONbits.SEN = 1;               // START condition\nwhile (I2C1CONbits.SEN);           // Wait for START complete\n\nI2C1TRN = 0b10100000;              // Send slave address (write mode)\nwhile (I2C1STATbits.TBF);          // Wait until byte sent\n\n// Wait for ACK from slave\nwhile (I2C1STATbits.ACKSTAT);      // 0 = ACK, 1 = NACK\n\nI2C1TRN = 0x00;                    // Send register address to read\nwhile (I2C1STATbits.TBF);\n\n// Restart condition to switch to read mode\nI2C1CONbits.RSEN = 1;\nwhile (I2C1CONbits.RSEN);\n\nI2C1TRN = 0b10100001;              // Send slave address (read mode)\nwhile (I2C1STATbits.TBF);\n\n// Wait for ACK, then enable receive\nwhile (I2C1STATbits.ACKSTAT);\nI2C1CONbits.RCEN = 1;              // Enable receive mode\n\nwhile (!I2C1STATbits.RBF);         // Wait for byte\nuint8_t value = I2C1RCV;           // Read received byte\n\nI2C1CONbits.PEN = 1;               // STOP condition\nwhile (I2C1CONbits.PEN);\n</code></pre>"},{"location":"chapters/chapter-8/#notes","title":"\u26a0\ufe0f Notes","text":"<ul> <li>I2C requires pull-up resistors on both SDA and SCL lines</li> <li>Only one master should control the bus at a time</li> <li>Communication is slower (~100\u2013400kHz typically), but very space-efficient</li> </ul> <p>Next, we\u2019ll look at how to read real-world analog signals using the ADC module.</p>"},{"location":"chapters/chapter-8/#quiz-i2c-communication","title":"\ud83e\udde0 Quiz: I2C Communication","text":"<p>Why does I2C require pull-up resistors on the SDA and SCL lines?</p> <ol> <li>To limit power draw from slaves  </li> <li>To allow multiple masters to drive the bus simultaneously  </li> <li>To ensure the lines return to HIGH when not actively driven  </li> <li>To increase the data rate of communication  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>I2C uses open-drain outputs, meaning devices can pull the line LOW but not drive it HIGH. Pull-up resistors ensure the lines default to HIGH when not being pulled down \u2014 allowing multiple devices to safely share the bus.</p>"},{"location":"chapters/chapter-8/#prompt-practice_2","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code to initiate an I2C transmission to a device with address <code>0x68</code>, send a register address <code>0x1C</code>, then restart and request a single byte of data from it.</p> Click to show solution <pre><code>// START condition\nI2C1CONbits.SEN = 1;\nwhile (I2C1CONbits.SEN);\n\n// Send slave address (write)\nI2C1TRN = 0xD0;                    // 0x68 &lt;&lt; 1 | 0 (write)\nwhile (I2C1STATbits.TBF);\nwhile (I2C1STATbits.ACKSTAT);     // Wait for ACK\n\n// Send register address (0x1C)\nI2C1TRN = 0x1C;\nwhile (I2C1STATbits.TBF);\n\n// RESTART condition\nI2C1CONbits.RSEN = 1;\nwhile (I2C1CONbits.RSEN);\n\n// Send slave address (read)\nI2C1TRN = 0xD1;                    // 0x68 &lt;&lt; 1 | 1 (read)\nwhile (I2C1STATbits.TBF);\nwhile (I2C1STATbits.ACKSTAT);\n\n// Enable receive mode\nI2C1CONbits.RCEN = 1;\nwhile (!I2C1STATbits.RBF);        // Wait for byte\n\nuint8_t result = I2C1RCV;         // Read data\n\n// STOP condition\nI2C1CONbits.PEN = 1;\nwhile (I2C1CONbits.PEN);\n</code></pre>"},{"location":"chapters/chapter-8/#section-5-adc-analog-to-digital-converter","title":"Section 5: ADC (Analog-to-Digital Converter)","text":"<p>Analog-to-Digital Conversion (ADC) lets your microcontroller read real-world analog signals \u2014 like voltage, temperature, or light level \u2014 and convert them into digital values it can process.</p>"},{"location":"chapters/chapter-8/#what-does-the-adc-do","title":"\ud83e\udde0 What Does the ADC Do?","text":"<p>An ADC samples an input voltage (e.g., 0\u20133.3V) and converts it into a digital number based on:</p> <ul> <li>Resolution (typically 10 bits on PIC24 \u2192 values from 0 to 1023)</li> <li>Reference Voltage (<code>VREF+</code> and <code>VREF-</code>)</li> <li>Sampling time (how long it takes to stabilize before conversion)</li> </ul> <p>For example, if <code>VREF+ = 3.3V</code>, then a reading of 512 \u2248 1.65V.</p>"},{"location":"chapters/chapter-8/#configuring-adc-on-pic24","title":"\u2699\ufe0f Configuring ADC on PIC24","text":"<p>Let\u2019s read analog voltage on AN0 (RB0) using the 10-bit ADC module.</p> <pre><code>// Configure RB0/AN0 as analog input\nAD1PCFGbits.PCFG0 = 0;          // Set AN0 as analog\nTRISBbits.TRISB0 = 1;           // Set RB0 as input\n\n// ADC Configuration\nAD1CON = 0;\nAD1CON1bits.FORM = 0;           // Integer output\nAD1CON1bits.SSRC = 7;           // Auto-convert\nAD1CON1bits.ASAM = 1;           // Auto-sample\n\nAD1CON2 = 0;                    // Use MUXA, Vref+ = AVdd, Vref- = AVss\nAD1CON3bits.ADCS = 2;           // ADC clock = Tcy \u00d7 (ADCS + 1)\nAD1CHSbits.CH0SA = 0;           // Select AN0\n\nAD1CON1bits.ADON = 1;           // Turn on ADC\n\n// Read a value\n__delay_ms(1);                  // Allow ADC to stabilize\nwhile (!AD1CON1bits.DONE);      // Wait for conversion\nuint16_t result = ADC1BUF0;     // Read the result\n</code></pre>"},{"location":"chapters/chapter-8/#example-conversions-10-bit-adc","title":"\ud83d\udccf Example Conversions (10-bit ADC)","text":"Input Voltage ADC Value 0.0 V 0 1.65 V 512 3.3 V 1023 <p>\ud83d\udcd0 ADC values are linear \u2014 you can scale them to voltage using: <code>V = (ADC / 1023.0) \u00d7 VREF</code></p> <p>Next up: a quick summary of all communication modules and where they\u2019re most useful!</p>"},{"location":"chapters/chapter-8/#section-6-summary-and-use-cases","title":"Section 6: Summary and Use Cases","text":"<p>Here's a quick recap of the communication and peripheral modules covered:</p> Module Use Case Pros Tradeoffs UART PC comms, debugging Simple, widely supported One-to-one only, no addressing SPI Sensors, memory, displays Fast, full-duplex Needs 4 wires, no native addressing I2C Multiple devices, clocks, EEPROMs Two wires, device addressing Slower, requires pull-ups ADC Sensors, analog input Converts real-world signals Needs stable voltage, limited speed <p>\ud83d\udee0\ufe0f Choose the right tool for the job \u2014 and test with real hardware whenever possible!</p>"},{"location":"chapters/chapter-8/#quiz-understanding-adc","title":"\ud83e\udde0 Quiz: Understanding ADC","text":"<p>You\u2019re using a 10-bit ADC with a reference voltage of 3.3V. What voltage does a digital reading of <code>682</code> most closely represent?</p> <ol> <li>1.1 V  </li> <li>2.2 V  </li> <li>3.0 V  </li> <li>3.3 V  </li> </ol> Show Answer <p>The correct answer is B (2.2 V).</p> <p>Use the conversion formula: <code>V = (ADC / 1023) \u00d7 VREF</code> \u2192 <code>(682 / 1023) \u00d7 3.3V \u2248 2.2V</code></p>"},{"location":"chapters/chapter-8/#prompt-practice_3","title":"\u270d\ufe0f Prompt Practice","text":"<p>Write code to configure the ADC to read from AN2 (RB2) and store the result in a variable.</p> Click to show solution <pre><code>// Configure AN2/RB2 as analog input\nAD1PCFGbits.PCFG2 = 0;           // AN2 = analog\nTRISBbits.TRISB2 = 1;            // RB2 as input\n\n// Basic ADC config\nAD1CON1bits.FORM = 0;            // Integer format\nAD1CON1bits.SSRC = 7;            // Auto-convert\nAD1CON1bits.ASAM = 1;            // Auto-sample\n\nAD1CON2 = 0;\nAD1CON3bits.ADCS = 2;\nAD1CHSbits.CH0SA = 2;            // Use AN2\n\nAD1CON1bits.ADON = 1;            // Enable ADC\n\n// Read the ADC value\n__delay_ms(1);\nwhile (!AD1CON1bits.DONE);\nuint16_t adcValue = ADC1BUF0;\n</code></pre> <p>That\u2019s the end of Chapter 8! \ud83c\udf89</p>"},{"location":"prompts/","title":"test for index - prompts","text":""},{"location":"prompts/enumerate-concepts/","title":"test for enumerate concepts","text":""},{"location":"prompts/feature-mapping/","title":"test for feature mapping","text":""},{"location":"prompts/generate-logo/","title":"test for generate logo","text":""},{"location":"sims/","title":"test for index - sims","text":""},{"location":"sims/sine-wave/","title":"Sine Wave Simulation","text":"<p>This simulation shows a real-time sine wave drawn using p5.js.</p>"},{"location":"tutorial/","title":"test for index - tutorial","text":""},{"location":"tutorial/admonitions/","title":"test for admonitions","text":""},{"location":"tutorial/getting-started/","title":"test for getting started","text":""},{"location":"tutorial/google-analytics/","title":"test for google analytics","text":""},{"location":"tutorial/navigation/","title":"test for navigation","text":""},{"location":"tutorial/quizzes/","title":"test for quizzes","text":""},{"location":"tutorial/upper-alpha-lists/","title":"test for upper alpha","text":""}]}