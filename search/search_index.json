{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My MkDocs Site","text":""},{"location":"about/","title":"test for about","text":"<ol> <li>Option one  </li> <li>Option two  </li> <li>Option three  </li> <li>Option four  </li> </ol>"},{"location":"contact/","title":"test for contact","text":""},{"location":"course-description/","title":"test for course description","text":"<p>Generate a Summary</p> <p>Please summarize the following passage using key bullet points.</p>"},{"location":"glossary/","title":"test for glossary","text":""},{"location":"how-we-built-this-site/","title":"test for how we built this site","text":""},{"location":"license/","title":"test for license","text":""},{"location":"references/","title":"test for references","text":""},{"location":"toc/","title":"test for table of content","text":""},{"location":"chapters/","title":"Welcome to My MkDocs Site","text":""},{"location":"chapters/chapter-1/","title":"Chapter 1: Introduction to Microcontrollers &amp; PIC24FJ64GA002","text":""},{"location":"chapters/chapter-1/#what-is-a-microcontroller","title":"What is a Microcontroller?","text":"<p>A microcontroller is a compact, self-contained computer system built onto a single integrated circuit. It includes a CPU (central processing unit), memory, and peripherals, making it well-suited for controlling embedded systems and real-world devices.</p>"},{"location":"chapters/chapter-1/#microcontroller-block-diagram","title":"Microcontroller Block Diagram","text":"<p>This diagram shows the typical internal structure of a microcontroller. The CPU core is supported by built-in memory and several peripheral modules such as timers, communication interfaces, and analog components.</p> <p> </p> <p>Unlike general-purpose computers, microcontrollers are designed for specific tasks, such as reading sensor data, driving motors, or communicating with other digital components. They are commonly used in systems that need low power, high reliability, and consistent timing.</p>"},{"location":"chapters/chapter-1/#key-characteristics","title":"Key Characteristics:","text":"<ul> <li>Small footprint: Microcontrollers are tiny, often used in devices with limited space.</li> <li>Real-time control: They\u2019re designed for deterministic behavior \u2014 ideal for time-sensitive applications.</li> <li>Integrated peripherals: Timers, analog-to-digital converters (ADCs), communication modules (UART, SPI, I2C), and more are built-in.</li> <li>Low power consumption: Designed for efficiency, especially in battery-powered devices.</li> </ul>"},{"location":"chapters/chapter-1/#common-use-cases","title":"Common Use Cases:","text":"<ul> <li>Home automation (e.g., smart thermostats)</li> <li>Robotics and motion control</li> <li>Automotive systems (e.g., airbag control)</li> <li>Industrial sensors and actuators</li> <li>Wearable electronics</li> </ul> <p>Microcontrollers are the backbone of embedded systems \u2014 small, purpose-built devices that power our modern, connected world.</p>"},{"location":"chapters/chapter-1/#common-microcontroller-applications","title":"Common Microcontroller Applications","text":"<p>Microcontrollers are used in thousands of everyday systems, often hidden inside devices that respond to inputs, control outputs, or handle timing and communication.</p> <p>Some common microcontroller-driven systems include:</p> <ul> <li>Home automation \u2013 smart thermostats, lighting systems, appliance control</li> <li>Wearables \u2013 smartwatches, fitness trackers, biometric sensors</li> <li>Automotive systems \u2013 engine control units, airbag deployment, infotainment</li> <li>Industrial automation \u2013 motors, valves, conveyor systems</li> <li>Consumer electronics \u2013 printers, game controllers, TVs, toys</li> <li>Medical devices \u2013 glucose monitors, blood pressure sensors, infusion pumps</li> </ul> <p>In each case, the microcontroller monitors inputs (like sensors or buttons), makes decisions via code, and triggers outputs (like motors, lights, or communications).</p>"},{"location":"chapters/chapter-1/#why-this-book-uses-the-pic24fj64ga002","title":"Why This Book Uses the PIC24FJ64GA002","text":"<p>This textbook focuses on the PIC24FJ64GA002, a 16-bit microcontroller from Microchip\u2019s PIC24 family. It strikes an ideal balance between complexity and learnability \u2014 advanced enough to support meaningful projects, but simple enough to teach the fundamentals of embedded systems clearly.</p> <p>The PIC24FJ64GA002 is widely used in academic and industry settings due to its:</p> <ul> <li>\u2705 Well-documented architecture</li> <li>\u2705 Rich set of on-chip peripherals</li> <li>\u2705 Smooth integration with MPLAB X IDE and the XC16 compiler</li> <li>\u2705 Strong ecosystem of tools, libraries, and example code</li> </ul>"},{"location":"chapters/chapter-1/#key-features-based-on-the-datasheet","title":"Key Features (Based on the Datasheet)","text":"Feature Description CPU Architecture 16-bit modified Harvard architecture Flash Memory 64 KB RAM 8 KB I/O Pins 24 I/O capable pins (in a 28 package pin) Timers Up to five 16-bit timers Communication UART, SPI, I2C ADC 10-bit resolution, up to 13 input channels Interrupt System Multi-priority vectored interrupt system Clock Options Internal and external oscillators (up to 32 MHz) Operating Voltage 2.0V to 3.6V <p>This microcontroller provides the right level of abstraction for learning low-level control, hardware interfacing, and system timing \u2014 without overwhelming new developers.</p> <p>\ud83d\udcce For full details, refer to the official PIC24FJ64GA002 Datasheet.</p>"},{"location":"chapters/chapter-1/#pic24fj64ga002-architecture-overview","title":"PIC24FJ64GA002 Architecture Overview","text":"<p>The PIC24FJ64GA002 is based on a 16-bit modified Harvard architecture. This means that it has separate memory spaces for instructions and data, which allows for more efficient fetching and execution of instructions.</p> <p>Unlike traditional Harvard designs, the PIC24 allows for flexible memory operations \u2014 instructions can access data memory, and certain instructions (like table reads/writes) can access program memory.</p>"},{"location":"chapters/chapter-1/#core-components-of-the-architecture","title":"Core Components of the Architecture","text":"Component Description CPU 16-bit core with a 2-stage pipeline (fetch/execute) Flash Memory 64 KB of non-volatile memory for storing program instructions RAM 8 KB of data memory for variables and temporary storage Registers 16 working registers (W0\u2013W15), used for all operations Stack Software-managed via dedicated stack pointer (no hardware push/pop instructions) Peripherals Timers, UART, SPI, I2C, ADC, output compare, input capture, etc. Interrupts Vectored interrupt system with multiple priority levels"},{"location":"chapters/chapter-1/#harvard-vs-von-neumann","title":"Harvard vs. Von Neumann","text":"<p>Most desktop computers use the Von Neumann architecture, where code and data share the same memory space. In contrast, the Harvard model separates them:</p> Feature Harvard Architecture Von Neumann Instruction Memory \u2705 Separate \u274c Shared Data Memory \u2705 Separate \u2705 Shared Performance \u2705 Faster (no bus conflict) \u274c Slower <p>The PIC24's modified Harvard design enables faster and more efficient execution for embedded systems.</p>"},{"location":"chapters/chapter-1/#register-centric-design","title":"Register-Centric Design","text":"<p>Most operations on the PIC24 use the 16 working registers (W0 to W15). These are: - Used as operands in arithmetic, logic, and data movement instructions - Referenced directly in assembly code - Some registers have special purposes (e.g., W15 is often used as the stack pointer)</p> <p>We'll explore register usage and memory addressing in more detail in the next chapter.</p>"},{"location":"chapters/chapter-2/","title":"Chapter 2: Assembly &amp; Addressing Modes","text":""},{"location":"chapters/chapter-2/#why-learn-assembly","title":"Why Learn Assembly?","text":"<p>Modern embedded systems are often programmed in high-level languages like C, but understanding assembly language is crucial for writing efficient, low-level code and truly mastering how a microcontroller works.</p> <p>Assembly gives you:</p> <ul> <li>\ud83d\udd0d Complete control over the CPU, memory, and peripheral access</li> <li>\u26a1 Performance optimizations that compilers can't always guarantee</li> <li>\ud83e\udde0 A deep understanding of what C code is actually doing \"under the hood\"</li> <li>\ud83d\udee0\ufe0f The ability to debug complex timing or hardware interaction issues</li> </ul> <p>Most high-level code on microcontrollers is eventually compiled into assembly \u2014 learning how to read and write it directly unlocks a new level of skill and insight.</p>"},{"location":"chapters/chapter-2/#pic24-assembly-basics","title":"PIC24 Assembly Basics","text":"<p>The PIC24 family uses a RISC (Reduced Instruction Set Computing) assembly language with a 16-bit word size. Each instruction typically executes in one cycle (excluding branching or memory fetches).</p> <p>In this chapter, we\u2019ll explore: - The basic syntax of PIC24 assembly - How data is moved between memory and registers - The different addressing modes (immediate, direct, indirect) - How to perform arithmetic and logical operations</p>"},{"location":"chapters/chapter-2/#basic-instruction-structure-syntax","title":"Basic Instruction Structure &amp; Syntax","text":"<p>Each PIC24 assembly instruction follows a simple, consistent structure:</p> <p><pre><code>OPCODE  OPERAND1, OPERAND2\n</code></pre> Where: - OPCODE is the operation to perform (e.g. MOV, ADD, SUB, etc.) - OPERAND1 is the source operand (what's being used for the operation) - OPERAND2 is the destination operand (where the result is stored)</p> <p>Example: Moving Data Between Registers <pre><code>    MOV     W1, W0      ; Copy contents of W1 into W0\n    MOV     #10, W2     ; Load the literal value 10 into W2\n</code></pre></p> <p>In the previous example:  - MOV W1, W0 takes the contents of W1 and stores it in W0 - MOV #10, W2 loads the immdeiate value 10 into W2</p> <p>Use semicolons (;) for comments in the PIC24 assembly: <pre><code>    CLR     W3          ; Clear W3 (set to zero)\n    ADD     W1, W2      ; Add W1 to W2 (result stored in W2)\n</code></pre></p>"},{"location":"chapters/chapter-2/#working-registers-w0w15","title":"Working Registers (W0\u2013W15)","text":"<p>PIC24 has 16 general-purpose working registers used for arithmetic, data movement, memory access, and stack operations.</p> Register Purpose Notes W0\u2013W13 General-purpose registers Used for operations, temporary storage W14 Frame Pointer (FP) Typically points to current stack frame W15 Stack Pointer (SP) Automatically updated on function calls"},{"location":"chapters/chapter-2/#common-pic24-assembly-instructions","title":"Common PIC24 Assembly Instructions","text":"Instruction Description <code>MOV</code> Move data between registers or from an immediate value <code>ADD</code> Add two registers or a register and a literal <code>SUB</code> Subtract one register from another <code>CLR</code> Clear a register (set it to 0) <code>INC</code> / <code>DEC</code> Increment / Decrement a register <code>CP</code> Compare two values (affects flags; used with branches)"},{"location":"chapters/chapter-2/#addressing-modes-in-pic24","title":"Addressing Modes in PIC24","text":"<p>Addressing modes define how data is accessed in an instruction. The PIC24 supports several flexible addressing modes, giving you control over where data comes from and how it's used.</p> <p>Here are the most common addressing modes:</p>"},{"location":"chapters/chapter-2/#1-immediate-addressing","title":"1. Immediate Addressing","text":"<p>Loads a constant (literal) value directly into a register.</p> <pre><code>MOV     #25, W0     ; #25 is a literal constant.\n                    ; Common for setting values or initializing data.\n</code></pre>"},{"location":"chapters/chapter-2/#2-register-direct","title":"2. Register Direct","text":"<p>Uses a working register directly as the source or desination.</p> <pre><code>MOV     W1, W2      ; Copy contents of W1 into W2.\n                    ; Fastest and simplest form.\n                    ; All operations using Wn (W0\u2013W15) fall under this mode.\n</code></pre>"},{"location":"chapters/chapter-2/#3-register-indirect","title":"3. Register Indirect","text":"<p>Uses a register as a pointer to data in memory</p> <pre><code>MOV     [W5], W0    ; Move value from address pointed to by W5 into W0.\n                    ; W5 contains the address, not the value itself.\n</code></pre>"},{"location":"chapters/chapter-2/#4-indirect-with-post-increment","title":"4. Indirect with Post-Increment","text":"<p>Automatically increments the pointer after the operation</p> <pre><code>MOV     [W6++], W1  ; Move from memory pointed to by W6 into W1.\n                    ; Then W6 = W6 + 2.\n                    ; Useful for reading data from arrays (word-aligned).\n</code></pre>"},{"location":"chapters/chapter-2/#5-indirect-with-pre-increment","title":"5. Indirect with Pre-Increment","text":"<p>Decrements the pointer before accessing the memory</p> <pre><code>MOV     [--W6], W1  ; W6 = W6 - 2, then move from new address into W1.\n                    ; Useful when reading a stack or traversing backward.\n</code></pre>"},{"location":"chapters/chapter-2/#6-literalwn","title":"6. Literal+Wn","text":"<p>Adds a literal offset to a base register</p> <pre><code>MOV     [W8 + 4], W0   ; Move from address (W8 + 4) into W0.\n                       ; Often used for structure fields or array access.\n                       ; Literal must be word-aligned (multiple of 2).\n</code></pre>"},{"location":"chapters/chapter-2/#chapter-summary","title":"Chapter Summary","text":"<p>In this chapter, we explored the fundamentals of PIC24 assembly language and how to work directly with the CPU's registers and memory.</p>"},{"location":"chapters/chapter-2/#self-check-quiz-styled-with-uppercase-letters","title":"Self-Check Quiz (Styled with Uppercase Letters)","text":"Which instruction correctly loads literal 25 into W5? <ol> <li>MOV W5, #25</li> <li>MOV [W5], 25</li> <li>MOV #25, W5</li> <li>LOAD 25 \u2192 W5</li> </ol> <p>Answer: C. <code>MOV #25, W5</code></p> Which instruction correctly loads literal 10 into W0? <p>```asm</p> Show Options <p> 1. <code>MOV W0, #10</code> 2. <code>MOV #10, W0</code> 3. <code>LOAD 10 \u2192 W0</code> 4. <code>MOV #W0, 10</code> </p> <p>Answer: B. <code>MOV #10, W0</code></p>"},{"location":"chapters/chapter-2/#practice-prompt","title":"Practice Prompt","text":"<p>Write a short PIC24 assembly program that:</p> <ul> <li>Loads the values 5 and 10 into two registers  </li> <li>Adds them together  </li> <li>Stores the result in <code>W2</code></li> </ul> <p>Try it yourself before revealing the solution!</p> Show Solution <pre><code>MOV     #10, W0      ; Load 10 into W0\nMOV     #5, W1       ; Load 5 into W1\nADD     W0, W1       ; Add W0 to W1 \u2192 W1 = 15\nMOV     W1, W2       ; Store the result in W2\n</code></pre>"},{"location":"chapters/chapter-2/#what-you-learned","title":"What You Learned:","text":"<ul> <li>The basic syntax of PIC24 assembly instructions</li> <li>The role of working registers (<code>W0\u2013W15</code>)</li> <li>How to use the MOV, <code>ADD</code>, <code>SUB</code>, and <code>CLR</code> instructions</li> <li>The key addressing modes:</li> <li>Immediate</li> <li>Register direct</li> <li>Indirect with pre/post increment</li> <li>Literal offset + register</li> </ul>"},{"location":"chapters/chapter-2/#why-it-matters","title":"Why It Matters:","text":"<ul> <li>Assembly gives you precise control over hardware</li> <li>It's the foundation for understanding how C code interacts with hardware</li> <li>You\u2019ll need these concepts when working with the stack, interrupts, and I/O peripherals</li> </ul>"},{"location":"chapters/chapter-2/#up-next-stack-call-and-function-frames","title":"Up Next: Stack, Call, and Function Frames","text":"<p>In Chapter 3, we'll explore: - How the PIC24 manages function calls - The use of <code>W14</code> as the frame pointer - How the stack works for passing data and preserving state</p> <p>You'll learn to set up and tear down stack frames manually \u2014 a crucial skill for writing low-level code that\u2019s reliable and efficient.</p> <ol> <li>Alpha</li> <li>Bravo</li> <li>Charlie</li> </ol>"},{"location":"chapters/chapter-3/","title":"Chapter 3: Stack, Call, and Function Frames","text":""},{"location":"chapters/chapter-3/#why-this-chapter-matters","title":"\ud83e\udde0 Why This Chapter Matters","text":"<p>This chapter explores how the PIC24 manages function calls, local variables, and return addresses using the stack. Understanding this helps you:</p> <ul> <li>Write assembly functions that interact cleanly with C code  </li> <li>Handle recursion, interrupts, and nested function calls  </li> <li>Use registers like <code>W14</code> (Frame Pointer) and <code>W15</code> (Stack Pointer) effectively  </li> </ul>"},{"location":"chapters/chapter-3/#section-1-what-is-the-stack","title":"\u2705 Section 1: What Is the Stack?","text":"<p>The stack is a region of RAM used for storing temporary data during program execution.</p> <ul> <li>LIFO (Last In, First Out) structure  </li> <li>Grows downward in memory (from high to low addresses)  </li> <li>Stores:  </li> <li>Return addresses  </li> <li>Local variables  </li> <li>Saved register values  </li> </ul>"},{"location":"chapters/chapter-3/#section-2-stack-related-registers","title":"\ud83e\uddf0 Section 2: Stack-Related Registers","text":"Register Purpose <code>W14</code> Frame Pointer (FP) \u2014 base of current stack frame <code>W15</code> Stack Pointer (SP) \u2014 points to the top of the stack <p>These registers are automatically used when calling/returning from functions in C, and are manually used in assembly when creating stack frames.</p>"},{"location":"chapters/chapter-3/#section-3-function-calls-the-call-stack","title":"\ud83d\udce5 Section 3: Function Calls &amp; the Call Stack","text":"<p>When a function is called:</p> <ol> <li>The return address is pushed onto the stack  </li> <li>Control jumps to the function  </li> <li>The callee function can:  </li> <li>Push <code>Wn</code> registers it will use  </li> <li>Allocate space for local variables  </li> <li>When the function finishes, the return address is popped  </li> <li>Execution resumes at the caller  </li> </ol>"},{"location":"chapters/chapter-3/#example-call-instruction","title":"Example: <code>CALL</code> Instruction","text":"<pre><code>CALL    myFunction\n</code></pre> <p>This:  - Pushes the program counter(return address)  - Jumps to myFunction</p>"},{"location":"chapters/chapter-3/#section-4-stack-frame-layout-manual-setup","title":"Section 4: Stack Frame Layout (Manual Setup)","text":"<p>You can manually manage the stack like this:  ; Prologue - setting up the stack frame PUSH    W0              ; Save register if needed PUSH    W1 MOV     W15, W14        ; Set Frame Pointer = Stack Pointer SUB     #4, W15         ; Allocate 4 bytes for local variables</p> <p>; Function body here...</p> <p>; Epilogue - cleaning up the stack <pre><code>MOV     W14, W15        ; Reset Stack Pointer\nPOP     W1\nPOP     W0\nRETURN\n</code></pre></p>"},{"location":"chapters/chapter-3/#section-5-why-its-important","title":"Section 5: Why It's Important","text":"<p>Without the stack, nested function calls wouldn't work. Local Variables would overwrite each other. Interrupt service routins would be unsafe.</p>"},{"location":"chapters/chapter-4/","title":"Chapter 4: Timers and Interrupts","text":""},{"location":"chapters/chapter-4/#what-are-timers","title":"\u23f1\ufe0f What Are Timers?","text":"<p>Timers are hardware modules in the PIC24 used for precise time measurement and periodic events. They\u2019re essential for:</p> <ul> <li>Creating delays</li> <li>Measuring time between events</li> <li>Triggering code execution at regular intervals</li> </ul>"},{"location":"chapters/chapter-4/#key-features","title":"Key Features:","text":"<ul> <li>Independent of CPU instructions</li> <li>Can be configured with different prescalers for flexible timing</li> <li>Often used to trigger interrupts</li> </ul>"},{"location":"chapters/chapter-4/#types-of-timers-in-pic24fj64ga002","title":"\u23f3 Types of Timers in PIC24FJ64GA002","text":"Timer Width Notes TMR1 16-bit Can generate interrupts TMR2 16-bit Often used with Output Compare TMR3 16-bit Can combine with TMR2 (32-bit mode) TMR4/5 16-bit Used for PWM or advanced timing <p>Each timer can be configured using special function registers (SFRs), such as:</p> <ul> <li><code>T1CON</code> \u2013 Timer1 Control Register  </li> <li><code>PR1</code> \u2013 Period register (defines when an interrupt should fire)  </li> <li><code>TMR1</code> \u2013 Current timer value  </li> </ul>"},{"location":"chapters/chapter-4/#timer-setup-example-timer1","title":"\u2699\ufe0f Timer Setup Example (Timer1)","text":"<pre><code>void setupTimer1() {\n    T1CON = 0x8030;   // Enable Timer1, prescaler 1:256\n    PR1 = 15625;      // Period register for 0.5s delay (assuming 8MHz clock)\n    TMR1 = 0;         // Reset timer\n    IEC0bits.T1IE = 1; // Enable Timer1 interrupt\n    IFS0bits.T1IF = 0; // Clear interrupt flag\n}\n\n## What Are Interrupts?\nInterrupts are special mechanisms that let the microcontroller respond to events(like a timer expiring or a ping changing) asynchronously - without constantly checking for them in code.\n\n### Common Interrupt Sources includes: \n - Timers\n - External pins(buttons)\n - Communication(UART, SPI, I2C)\n - ADC conversions\n\n## \ud83e\udde0 How Interrupts Work\n\n1. An interrupt **event** occurs (e.g., Timer1 hits PR1)  \n2. The CPU **pauses** normal execution  \n3. Jumps to a special function: the **Interrupt Service Routine (ISR)**  \n4. After ISR finishes, **execution resumes** where it left off\n\n\n### Example: Timer1 Interrupt Handler \n```c\nvoid __attribute__((interrupt, no_auto_psv)) _T1Interrupt(void) {\n    IFS0bits.T1IF = 0;  // Clear interrupt flag\n    LATBbits.LATB0 = 1; // Toggle LED on RB0\n}\n</code></pre>"},{"location":"chapters/chapter-4/#notes-on-interrupts","title":"\ud83e\udde9 Notes on Interrupts","text":"<ul> <li>Always clear the interrupt flag first inside the ISR!  </li> <li>Use the correct ISR name (e.g., <code>_T1Interrupt</code> for Timer1)  </li> <li>Keep ISRs short and fast </li> <li>Use <code>__attribute__((interrupt))</code> to declare an ISR in C</li> </ul>"},{"location":"chapters/chapter-4/#summary","title":"Summary","text":"<p>Timers allow precise time-based operations Interrupts let you react to events without polling Together, they enable efficient embedded systems</p>"},{"location":"chapters/chapter-5/","title":"Chapter 5: External Interrupts","text":""},{"location":"chapters/chapter-5/#what-are-external-interrupts","title":"\ud83d\udcdf What Are External Interrupts?","text":"<p>External interrupts allow the microcontroller to respond immediately to changes on input pins \u2014 such as buttons, sensors, or other devices triggering a logic change.</p> <p>They are incredibly useful for handling real-time user input or reacting to asynchronous events.</p>"},{"location":"chapters/chapter-5/#key-pins-and-registers","title":"\ud83d\udccc Key Pins and Registers","text":"<p>PIC24 devices support multiple external interrupts using special pins:</p> Interrupt Pin Description INT0 Usually RB7 Edge-triggered, non-maskable INT1 Configurable Edge-triggered, maskable INT2 Configurable Edge-triggered, maskable"},{"location":"chapters/chapter-5/#important-registers","title":"Important Registers:","text":"Register / Bit Purpose <code>INTxIF</code> (IFSx) Interrupt Flag \u2014 set when the event occurs <code>INTxIE</code> (IECx) Interrupt Enable \u2014 must be set to 1 <code>INTxEP</code> Edge polarity (1 = falling, 0 = rising) <code>RPINR0</code>, <code>RPINR1</code>, \u2026 Remappable pins for INT1, INT2 (if supported)"},{"location":"chapters/chapter-5/#edge-triggered-behavior","title":"\ud83e\udde0 Edge-Triggered Behavior","text":"<p>You can configure external interrupts to trigger on:</p> <ul> <li>Rising edge: logic level 0 \u2192 1 (e.g., button press)</li> <li>Falling edge: logic level 1 \u2192 0 (e.g., button release)</li> </ul> <p>This is controlled by the <code>INTxEP</code> bit.</p>"},{"location":"chapters/chapter-5/#example-int0-button-interrupt","title":"\u26a1 Example: INT0 Button Interrupt","text":"<pre><code>void __attribute__((interrupt, no_auto_psv)) _INT0Interrupt(void) {\n    IFS0bits.INT0IF = 0;     // Clear interrupt flag\n    LATBbits.LATB0 = 1;     // Toggle an LED\n}\n</code></pre>"},{"location":"chapters/chapter-5/#setup-code","title":"Setup Code:","text":"<pre><code>TRISBbits.TRISB7 = 1;     // Set RB7 (INT0) as input\nINTCON2bits.INT0EP = 1;   // Trigger on falling edge\nIFS0bits.INT0IF = 0;      // Clear flag\nIEC0bits.INT0IE = 1;      // Enable INT0 interrupt\n</code></pre>"},{"location":"chapters/chapter-5/#best-practices","title":"\ud83e\udde9 Best Practices","text":"<ul> <li>Always clear the interrupt flag (<code>INTxIF</code>) at the start or end of the ISR  </li> <li>Use pull-up/down resistors to prevent floating inputs  </li> <li>Debounce mechanical inputs (like buttons) in software or hardware  </li> <li>Keep the ISR short and efficient</li> </ul>"},{"location":"chapters/chapter-5/#use-cases","title":"\ud83e\udde0 Use Cases","text":"<ul> <li>Button presses  </li> <li>Motion detectors  </li> <li>Limit switches in robotics  </li> <li>External sensor signals</li> </ul>"},{"location":"chapters/chapter-6/","title":"Chapter 6: Input Capture","text":""},{"location":"chapters/chapter-6/#what-is-input-capture","title":"\ud83c\udfaf What Is Input Capture?","text":"<p>Input Capture allows the PIC24 to record the exact time a digital signal changes, such as rising or falling edges on an input pin. It\u2019s useful for:</p> <ul> <li>Measuring pulse width </li> <li>Determining frequency </li> <li>Capturing timestamped events (e.g., RPM sensors, echo returns)</li> </ul>"},{"location":"chapters/chapter-6/#how-it-works","title":"\u23f1\ufe0f How It Works","text":"<ol> <li>A timer (e.g., TMR2) is running in the background  </li> <li>When a signal edge is detected, the current timer value is saved in a capture register  </li> <li>An interrupt can be triggered to notify the CPU  </li> <li>The program can read the captured time</li> </ol>"},{"location":"chapters/chapter-6/#key-registers","title":"\ud83e\uddf0 Key Registers","text":"Register Description <code>ICxBUF</code> Capture buffer \u2014 holds captured timer value <code>ICxCON1</code> Control register for Input Capture <code>ICxCON2</code> Advanced features (chaining, sync) <code>IFSx</code>, <code>IECx</code> Interrupt flag and enable bits for Input Capture <code>TMRy</code> Timer used as the timebase (usually TMR2 or TMR3)"},{"location":"chapters/chapter-6/#example-measure-pulse-width-with-input-capture-1","title":"\u2699\ufe0f Example: Measure Pulse Width with Input Capture 1","text":"<p>Let\u2019s say we want to measure the time between two rising edges of a signal.</p>"},{"location":"chapters/chapter-6/#configuration","title":"Configuration:","text":"<pre><code>void setupInputCapture1() {\n    T2CON = 0x8000;      // Enable Timer2, no prescale\n    IC1CON1 = 0x0003;    // Capture every rising edge\n    IC1CON2 = 0x0000;    // Use Timer2 as timebase\n    IFS0bits.IC1IF = 0;  // Clear interrupt flag\n    IEC0bits.IC1IE = 1;  // Enable IC1 interrupt\n}\n</code></pre>"},{"location":"chapters/chapter-6/#interrupt-service-routine","title":"Interrupt Service Routine","text":"<pre><code>uint16_t lastCapture = 0;\nuint16_t pulseWidth = 0;\n\nvoid __attribute__((interrupt, no_auto_psv)) _IC1Interrupt(void) {\n    IFS0bits.IC1IF = 0;                  // Clear flag\n    uint16_t current = IC1BUF;           // Read captured value\n    pulseWidth = current - lastCapture;  // Compute pulse width\n    lastCapture = current;               // Store for next edge\n}\n</code></pre>"},{"location":"chapters/chapter-6/#use-cases-for-input-capture","title":"\ud83e\udde0 Use Cases for Input Capture","text":"<ul> <li>Measure the frequency of an external waveform  </li> <li>Detect the width of ultrasonic echo pulses  </li> <li>Determine RPM from motor encoders  </li> <li>Track signal timing in communication protocols  </li> </ul>"},{"location":"chapters/chapter-6/#tips","title":"\ud83e\udde9 Tips","text":"<ul> <li>Make sure the timer used is running!  </li> <li>Avoid overflow \u2014 use a large enough timer or handle wraparound  </li> <li>Debounce noisy signals to avoid false captures  </li> <li>Use capture every edge, every 2nd edge, or rising/falling as needed via <code>ICxCON1</code> settings  </li> </ul>"},{"location":"chapters/chapter-7/","title":"Chapter 7: Output Compare","text":""},{"location":"chapters/chapter-7/#what-is-output-compare","title":"\ud83c\udfaf What Is Output Compare?","text":"<p>The Output Compare (OC) module is used to generate timed digital outputs on a pin. It\u2019s most commonly used for:</p> <ul> <li>Generating PWM (Pulse Width Modulation) signals  </li> <li>Producing precise single-shot pulses </li> <li>Creating timed toggles for waveform generation  </li> </ul> <p>It works alongside a timer (like TMR2 or TMR3) to compare the timer\u2019s value against programmed thresholds.</p>"},{"location":"chapters/chapter-7/#key-registers","title":"\ud83e\uddf0 Key Registers","text":"Register Description <code>OCxCON1</code> Main control register for OC module <code>OCxCON2</code> Sync options, advanced features <code>OCxR</code> Compare register (start of pulse) <code>OCxRS</code> Secondary register (end of pulse) <code>TMRy</code> Timer driving the output compare"},{"location":"chapters/chapter-7/#how-pwm-works-with-output-compare","title":"\u26a1 How PWM Works with Output Compare","text":"<p>PWM signals switch between high and low at regular intervals:</p> <ul> <li>The duty cycle (how long the signal is high) is controlled by <code>OCxRS</code></li> <li>The period is defined by the timer (typically via <code>PR2</code>)</li> <li>OC pins can be routed using the Peripheral Pin Select (PPS) system</li> </ul>"},{"location":"chapters/chapter-7/#example-generate-1-khz-pwm-on-oc1","title":"\u2699\ufe0f Example: Generate 1 kHz PWM on OC1","text":"<pre><code>void setupOC1_PWM() {\n    // Configure Timer2 for 1 kHz (assuming 8 MHz clock, prescaler 1:64)\n    T2CON = 0x8030;      // Enable TMR2, prescaler 1:64\n    PR2 = 1249;          // Period = (8MHz / 64 / 1kHz) - 1\n\n    OC1CON1 = 0x0006;    // OC1 in edge-aligned PWM mode\n    OC1R = 0;            // Initial duty cycle = 0\n    OC1RS = 625;         // 50% duty cycle (625 out of 1250)\n\n    // Route OC1 to pin using PPS (example: RP3)\n    RPOR1bits.RP3R = 18; // RP3 = OC1\n\n    OC1CON1bits.OCM = 0b110; // Enable OC1 in PWM mode\n} // This sets up a clean 1kHz PWM output with a 50% duty cycle\n</code></pre>"},{"location":"chapters/chapter-7/#use-cases","title":"\ud83e\udde0 Use Cases","text":"<ul> <li>Dim LEDs with PWM  </li> <li>Control motor speed (DC or servo motors)  </li> <li>Generate audio tones  </li> <li>Create square waves or timing pulses  </li> <li>Trigger external circuitry at precise intervals  </li> </ul>"},{"location":"chapters/chapter-7/#tips","title":"\ud83e\udde9 Tips","text":"<ul> <li>OC modules require a running timer (e.g., TMR2 or TMR3)  </li> <li><code>OCxRS</code> defines the on-time, <code>PRx</code> defines the total period </li> <li>Always route the OC output to a pin via Peripheral Pin Select (PPS) </li> <li>Use <code>OCxCON1bits.OCM</code> to select the mode (PWM, single compare, etc.)  </li> </ul>"},{"location":"chapters/chapter-8/","title":"Chapter 8: Analog-to-Digital Conversion (ADC)","text":""},{"location":"chapters/chapter-8/#what-is-adc","title":"\ud83c\udfaf What Is ADC?","text":"<p>The Analog-to-Digital Converter (ADC) module allows the PIC24 to convert an analog voltage (e.g., from a sensor) into a digital value that your program can work with.</p> <ul> <li>Analog signals: continuous (e.g., 0\u20133.3V)  </li> <li>Digital output: discrete (e.g., 0\u20131023 for a 10-bit ADC)  </li> <li>Converts voltage into a digital number using successive approximation</li> </ul>"},{"location":"chapters/chapter-8/#how-adc-works","title":"\ud83d\udd0d How ADC Works","text":"<ol> <li>Select an analog input channel (e.g., AN0, AN1, etc.)</li> <li>Start the conversion</li> <li>Wait for conversion to complete (or use an interrupt)</li> <li>Read the result from the <code>ADC1BUF</code> register</li> </ol>"},{"location":"chapters/chapter-8/#key-registers","title":"\u2699\ufe0f Key Registers","text":"Register Description <code>AD1CON1</code> Main ADC control (start/stop, conversion type) <code>AD1CON2</code> Input scan, buffer settings <code>AD1CON3</code> Sample time, ADC clock <code>AD1CHS</code> Selects the input channel <code>ADC1BUF0</code> Holds the result of the latest conversion <code>IFS0bits.AD1IF</code> ADC interrupt flag <code>IEC0bits.AD1IE</code> ADC interrupt enable"},{"location":"chapters/chapter-8/#example-read-analog-voltage-on-an0","title":"\u26a1 Example: Read Analog Voltage on AN0","text":"<pre><code>void setupADC() {\n    AD1CON1 = 0x00E0;      // Auto-convert after sampling\n    AD1CON2 = 0x0000;      // Single channel, single conversion\n    AD1CON3 = 0x1F3F;      // Sample time and ADC clock\n    AD1CHS = 0x0000;       // Select AN0 for input\n    AD1CSSL = 0;           // No scanning\n    AD1CON1bits.ADON = 1;  // Turn on ADC\n}\n\nuint16_t readADC() {\n    AD1CON1bits.SAMP = 1;          // Start sampling\n    __delay_us(10);                // Delay for sampling time\n    AD1CON1bits.SAMP = 0;          // Start conversion\n    while (!AD1CON1bits.DONE);     // Wait for conversion complete\n    return ADC1BUF0;               // Return result\n}\n</code></pre>"},{"location":"chapters/chapter-8/#use-cases","title":"\ud83e\udde0 Use Cases","text":"<ul> <li>Read values from analog sensors (e.g., temperature, light, potentiometer)  </li> <li>Measure voltages for battery monitoring  </li> <li>Sample waveforms or analog signals for processing  </li> <li>Use analog inputs as threshold triggers (e.g., above/below reference)</li> </ul>"},{"location":"chapters/chapter-8/#tips","title":"\ud83e\udde9 Tips","text":"<ul> <li>Ensure the analog pin is set to input (<code>TRISx = 1</code>)  </li> <li>Disable the digital output on analog pins (<code>AD1PCFG</code>) if needed  </li> <li>Sampling too quickly can reduce accuracy \u2014 tune sample time via <code>AD1CON3</code> </li> <li>Use averaging in software to reduce noise in the signal  </li> <li>Consider using interrupts for more efficient conversions</li> </ul>"},{"location":"prompts/","title":"test for index - prompts","text":""},{"location":"prompts/enumerate-concepts/","title":"test for enumerate concepts","text":""},{"location":"prompts/feature-mapping/","title":"test for feature mapping","text":""},{"location":"prompts/generate-logo/","title":"test for generate logo","text":""},{"location":"sims/","title":"test for index - sims","text":""},{"location":"sims/sine-wave/","title":"Sine Wave Simulation","text":"<p>This simulation shows a real-time sine wave drawn using p5.js.</p>"},{"location":"tutorial/","title":"test for index - tutorial","text":""},{"location":"tutorial/admonitions/","title":"test for admonitions","text":""},{"location":"tutorial/getting-started/","title":"test for getting started","text":""},{"location":"tutorial/google-analytics/","title":"test for google analytics","text":""},{"location":"tutorial/navigation/","title":"test for navigation","text":""},{"location":"tutorial/quizzes/","title":"test for quizzes","text":""},{"location":"tutorial/upper-alpha-lists/","title":"test for upper alpha","text":""}]}