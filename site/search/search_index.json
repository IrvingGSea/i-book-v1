{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Embedded Systems with the PIC24","text":"<p>Welcome! This intelligent textbook is designed to guide you through a collegiate-level course in embedded systems programming using the PIC24FJ64GA002 microcontroller.</p> <p>Throughout the chapters, you\u2019ll gain hands-on experience with:</p> <ul> <li>PIC24 architecture and assembly language</li> <li>Timers, interrupts, and peripheral control</li> <li>Serial communication (UART, SPI, I2C)</li> <li>Real-time interaction using input/output hardware</li> <li>Embedded C and low-level programming techniques</li> </ul> <p>Many of the features on this site include AI-generated content and interactive components such as:</p> <ul> <li>Prompt-based exercises</li> <li>Knowledge check quizzes</li> <li>Microcontroller simulations (MicroSims)</li> </ul> <p>This textbook is built using <code>MkDocs</code> and the <code>Material for MkDocs</code> theme, with content version-controlled and deployed using GitHub Pages.</p> <p>Created by Irving Garcia Contact: garc0817@umn.edu</p> <p>Welcome to our Intelligent Textbooks with MkDocs Material.</p> <p>This GitHub repository is based on the mkdocs-for-intelligent-textbooks tutorial available here: Getting Started with Intelligent Textbooks</p>"},{"location":"about/","title":"About This Textbook","text":"<p>This intelligent textbook was created to provide students with a hands-on, interactive introduction to embedded systems programming using the PIC24FJ64GA002 microcontroller by Microchip.</p> <p>The book blends traditional explanations with modern tools like Markdown, interactive prompts, and MicroSims to reinforce deep learning and experimentation.</p>"},{"location":"about/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this textbook, learners should be able to:</p> <ul> <li>Understand the architecture of the PIC24FJ64GA002 microcontroller</li> <li>Write and debug assembly code for core operations (branching, loops, stack management)</li> <li>Use timers, interrupts, and peripheral modules (UART, SPI, I2C, ADC)</li> <li>Read datasheets and configure registers for real-time control</li> <li>Translate embedded concepts into working C/assembly implementations</li> </ul>"},{"location":"about/#intended-audience","title":"Intended Audience","text":"<p>This resource is designed for:</p> <ul> <li>Undergraduate students in Computer Engineering, Electrical Engineering, or Embedded Systems</li> <li>Makers, hobbyists, and developers interested in microcontrollers</li> <li>Anyone learning real-time programming with resource-constrained devices</li> </ul>"},{"location":"about/#approach","title":"Approach","text":"<p>The structure of this book mirrors a lab-based embedded systems course. Each chapter builds incrementally:</p> <ul> <li>Assembly concepts and syntax \u2192  </li> <li>Control structures and memory \u2192  </li> <li>Peripherals, interrupts, and real-world interfacing</li> </ul> <p>Interactive elements such as quizzes, prompt challenges, and simulations are embedded to reinforce key ideas.</p>"},{"location":"about/#author-acknowledgements","title":"Author &amp; Acknowledgements","text":"<p>This project was developed by Irving Garcia as part of a university-level embedded systems curriculum.</p> <p>Special thanks to:</p> <ul> <li>Dan McCreary who inspired this structure</li> <li>Microchip for documentation and tools</li> <li>Open-source developers of MkDocs and Material for MkDocs</li> </ul> <p>This book is open to future contributions and improvements. If you'd like to help, check the GitHub repository for open issues or submit your suggestions.</p>"},{"location":"contact/","title":"Contact","text":"<p>Have questions, suggestions, or found an issue in the textbook? We\u2019d love to hear from you!</p>"},{"location":"contact/#contribute-or-report-an-issue","title":"Contribute or Report an Issue","text":"<p>This intelligent textbook is hosted on GitHub. You can:</p> <ul> <li>Submit feedback or report bugs by opening an Issue on GitHub</li> <li>Suggest improvements by submitting a Pull Request</li> <li>Ask questions or request features in the Discussions tab</li> </ul>"},{"location":"contact/#contact-author","title":"Contact Author","text":"<p>If you\u2019d like to reach out directly, you can contact me at:</p> <p>\ud83d\udce8 Email: Irving \ud83d\udd17 GitHub: IrvingGSea</p> <p>Thank you for helping improve this textbook!</p>"},{"location":"course-description/","title":"Course Description","text":"<p>This course introduces students to the fundamentals of embedded systems programming using the PIC24FJ64GA002 microcontroller. Through a combination of low-level assembly, C programming, and hands-on interaction with hardware peripherals, students gain practical experience designing, coding, and debugging microcontroller-based systems.</p> <p>The course emphasizes not only syntax and structure, but also the real-world applications of embedded programming \u2014 such as controlling timers, handling interrupts, reading sensors, and sending data over serial interfaces.</p>"},{"location":"course-description/#topics-covered","title":"Topics Covered","text":"<ul> <li>Microcontroller architecture and memory mapping</li> <li>Writing and debugging PIC24 assembly code</li> <li>Branching, loops, and conditional execution</li> <li>Stack behavior, subroutines, and frame pointers</li> <li>Timers, periodic interrupts, and real-time control</li> <li>External interrupts and input capture modules</li> <li>Output compare and pulse-width modulation (PWM)</li> <li>Communication protocols: UART, SPI, I2C</li> <li>Analog-to-digital conversion (ADC)</li> </ul>"},{"location":"course-description/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of the course, students will be able to:</p> <ul> <li>Understand and manipulate hardware-level control flow</li> <li>Interface with peripherals such as buttons, LEDs, and sensors</li> <li>Configure and use timers, interrupts, and communication modules</li> <li>Translate datasheet specifications into working embedded code</li> <li>Build efficient, deterministic programs suitable for resource-constrained devices</li> </ul>"},{"location":"course-description/#tools-environment","title":"Tools &amp; Environment","text":"<p>Students will use the following tools:</p> <ul> <li>MPLAB X IDE and XC16 compiler</li> <li>PIC24FJ64GA002 development board</li> <li>Microchip datasheets and technical documentation</li> <li>This intelligent, interactive textbook with embedded quizzes and simulations</li> </ul> <p>This course is ideal for students in electrical engineering, computer engineering, or related fields looking to understand the foundations of embedded systems through a hands-on, low-level lens.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>This glossary defines key terms used throughout the textbook. You can link to any term using standard Markdown linking.</p>"},{"location":"glossary/#adc-analog-to-digital-converter","title":"ADC (Analog-to-Digital Converter)","text":"<p>A module that converts real-world analog voltages into digital values that a microcontroller can process.</p>"},{"location":"glossary/#ack-nack","title":"ACK / NACK","text":"<p>Signals used in I2C communication. ACK (Acknowledge) confirms successful data receipt; NACK (Not Acknowledge) denies it.</p>"},{"location":"glossary/#addressing-mode","title":"Addressing Mode","text":"<p>A method of specifying how and where to access data in assembly instructions (e.g., immediate, direct, indirect).</p>"},{"location":"glossary/#assembly-language","title":"Assembly Language","text":"<p>A low-level programming language that provides direct control of the hardware using symbolic instructions.</p>"},{"location":"glossary/#baud-rate","title":"Baud Rate","text":"<p>The number of bits transmitted per second in a serial communication protocol such as UART.</p>"},{"location":"glossary/#bne-branch-if-not-equal","title":"BNE (Branch if Not Equal)","text":"<p>A conditional branch instruction that causes program flow to jump if the zero flag is not set.</p>"},{"location":"glossary/#bra-branch-always","title":"BRA (Branch Always)","text":"<p>An unconditional branch instruction used to jump to a labeled section of code.</p>"},{"location":"glossary/#call-stack","title":"Call Stack","text":"<p>A memory structure that stores return addresses and local variables when subroutines are called.</p>"},{"location":"glossary/#call","title":"CALL","text":"<p>An instruction used to invoke a subroutine or function.</p>"},{"location":"glossary/#compare-cp","title":"Compare (CP)","text":"<p>An instruction that subtracts one value from another and sets flags based on the result \u2014 used before conditional branches.</p>"},{"location":"glossary/#dac-digital-to-analog-converter","title":"DAC (Digital-to-Analog Converter)","text":"<p>A peripheral that converts digital values into analog voltage. (Mentioned as a conceptual opposite to ADC.)</p>"},{"location":"glossary/#debouncing","title":"Debouncing","text":"<p>The process of filtering out signal noise or bouncing, especially for buttons or mechanical switches.</p>"},{"location":"glossary/#dec-inc","title":"DEC / INC","text":"<p>Decrement or Increment \u2013 arithmetic instructions used to subtract or add 1 to a register.</p>"},{"location":"glossary/#flag-condition-code","title":"Flag (Condition Code)","text":"<p>A single-bit status indicator (e.g., Z for zero, C for carry, N for negative) used for conditional branching in assembly.</p>"},{"location":"glossary/#firmware","title":"Firmware","text":"<p>The permanent software programmed into the microcontroller's Flash memory.</p>"},{"location":"glossary/#frame-pointer-w14","title":"Frame Pointer (W14)","text":"<p>A register that helps reference variables in stack frames during function calls.</p>"},{"location":"glossary/#goto","title":"GOTO","text":"<p>An instruction that jumps to a specific labeled location in code.</p>"},{"location":"glossary/#immediate-value","title":"Immediate Value","text":"<p>A constant literal used directly in an instruction, usually prefixed with <code>#</code> (e.g., <code>#10</code>).</p>"},{"location":"glossary/#interrupt","title":"Interrupt","text":"<p>A signal that temporarily halts the normal program flow to run a special function called an Interrupt Service Routine (ISR).</p>"},{"location":"glossary/#isr-interrupt-service-routine","title":"ISR (Interrupt Service Routine)","text":"<p>A function that runs automatically in response to an interrupt and returns control to the main program afterward.</p>"},{"location":"glossary/#i2c-inter-integrated-circuit","title":"I2C (Inter-Integrated Circuit)","text":"<p>A two-wire serial communication protocol supporting multiple devices using addressing and shared lines.</p>"},{"location":"glossary/#microcontroller","title":"Microcontroller","text":"<p>A compact integrated circuit that includes a CPU, memory, and peripherals for real-time control of embedded systems.</p>"},{"location":"glossary/#mplab-x-ide","title":"MPLAB X IDE","text":"<p>Microchip\u2019s official development environment for programming PIC microcontrollers.</p>"},{"location":"glossary/#nop","title":"NOP","text":"<p>An instruction that does nothing for one instruction cycle. Useful for breakpoints and timing.</p>"},{"location":"glossary/#operand","title":"Operand","text":"<p>A value or register used in an assembly instruction (e.g., source or destination in a <code>MOV</code> instruction).</p>"},{"location":"glossary/#opcode","title":"Opcode","text":"<p>The operation code in assembly language that tells the processor what action to perform (e.g., <code>MOV</code>, <code>ADD</code>).</p>"},{"location":"glossary/#output-compare","title":"Output Compare","text":"<p>A peripheral that compares a timer value to a preset and triggers an event \u2014 often used for PWM generation.</p>"},{"location":"glossary/#pic24fj64ga002","title":"PIC24FJ64GA002","text":"<p>The 16-bit microcontroller used in this textbook, produced by Microchip, featuring timers, ADCs, UART, and more.</p>"},{"location":"glossary/#polling","title":"Polling","text":"<p>A method where the CPU continuously checks a condition (e.g., a flag or register), instead of responding to interrupts.</p>"},{"location":"glossary/#pps-peripheral-pin-select","title":"PPS (Peripheral Pin Select)","text":"<p>A Microchip feature that allows flexible assignment of internal peripheral inputs/outputs to physical pins.</p>"},{"location":"glossary/#prescaler","title":"Prescaler","text":"<p>A divider that reduces the clock frequency input to a timer, allowing for longer timing intervals.</p>"},{"location":"glossary/#prx-period-register","title":"PRx (Period Register)","text":"<p>Register used to define the match/reset value of a timer, controlling when it overflows or triggers an interrupt.</p>"},{"location":"glossary/#prompt","title":"Prompt","text":"<p>A short, scenario-based coding challenge intended to help students apply concepts through practice.</p>"},{"location":"glossary/#pwm-pulse-width-modulation","title":"PWM (Pulse-Width Modulation)","text":"<p>A method for simulating analog output using digital pulses of variable duty cycle \u2014 used in motor control, dimming, etc.</p>"},{"location":"glossary/#register-w0w15","title":"Register (W0\u2013W15)","text":"<p>A small, fast-access memory location in the CPU used to hold data during computation.</p>"},{"location":"glossary/#ret","title":"RET","text":"<p>An instruction that returns from a subroutine by restoring the last return address from the stack.</p>"},{"location":"glossary/#stack","title":"Stack","text":"<p>A last-in, first-out (LIFO) memory structure used for storing return addresses and function call data.</p>"},{"location":"glossary/#stack-pointer-w15","title":"Stack Pointer (W15)","text":"<p>A special-purpose register that always points to the top of the call stack.</p>"},{"location":"glossary/#subroutine","title":"Subroutine","text":"<p>A reusable block of code (a function) that can be called from multiple places in the program.</p>"},{"location":"glossary/#timer","title":"Timer","text":"<p>A peripheral that counts clock cycles and can generate interrupts when it matches a preset value.</p>"},{"location":"glossary/#uart-universal-asynchronous-receivertransmitter","title":"UART (Universal Asynchronous Receiver/Transmitter)","text":"<p>A hardware module for asynchronous serial communication using TX/RX lines.</p>"},{"location":"glossary/#watchdog-timer-wdt","title":"Watchdog Timer (WDT)","text":"<p>A system-reset timer that triggers a reset if the program stops running or hangs unexpectedly.</p>"},{"location":"glossary/#working-register","title":"Working Register","text":"<p>One of 16 fast-access registers (<code>W0</code>\u2013<code>W15</code>) used for computation, memory access, and control flow.</p>"},{"location":"glossary/#xor","title":"XOR","text":"<p>A bitwise logic operation that outputs true when inputs differ \u2014 often used for toggling values.</p>"},{"location":"how-we-built-this-site/","title":"How We Built This Site","text":"<p>This intelligent textbook was built using the following tools and technologies:</p> <ul> <li>MkDocs \u2014 A static site generator for building project documentation.</li> <li>MkDocs Material Theme \u2014 Provided the styling, tabs, sidebars, and callout boxes.</li> <li>Python \u2014 Used to manage the environment and install necessary MkDocs plugins.</li> <li>GitHub \u2014 Hosted the Markdown files, source code, and configuration.</li> <li>GitHub Pages \u2014 Served the final static website from the <code>gh-pages</code> branch.</li> <li>VS Code \u2014 Used for writing, editing, and live previewing Markdown files.</li> <li>Custom MicroSimulations \u2014 Built using HTML, CSS, JavaScript, and p5.js or vis.js where applicable.</li> <li>AI Collaboration \u2014 Some educational content was assisted through LLMs such as ChatGPT.</li> </ul> <p>The project was inspired by modern open educational resources and intelligent textbooks that combine traditional material with interactive simulations and quizzes.</p>"},{"location":"references/","title":"References","text":"<p>Below is a list of key tools, technologies, and platforms referenced in the development and deployment of this intelligent textbook on Embedded Systems with the PIC24FJ64GA002.</p>"},{"location":"references/#chatgpt-openai","title":"ChatGPT (OpenAI)","text":"<p>Used to help brainstorm, draft, revise, and format textbook content, quizzes, prompts, and explanations throughout the development process.</p>"},{"location":"references/#mkdocs","title":"MkDocs","text":"<p>A static site generator that turns Markdown files into a clean, structured documentation website. It\u2019s the backbone of this intelligent textbook platform.</p>"},{"location":"references/#mkdocs-material-theme","title":"MkDocs Material Theme","text":"<p>A beautiful and highly customizable theme for MkDocs that supports tabs, collapsible blocks, code highlighting, admonitions, and responsive layouts. Perfect for educational content.</p>"},{"location":"references/#github-pages","title":"GitHub Pages","text":"<p>Used to host the live version of the intelligent textbook directly from the GitHub repository. Free, version-controlled, and simple to deploy.</p>"},{"location":"references/#markdown","title":"Markdown","text":"<p>The lightweight markup language used to write every chapter, quiz, glossary entry, and tutorial. Markdown\u2019s simplicity made it ideal for modular content creation.</p>"},{"location":"references/#deploy-mkdocs-github-action","title":"Deploy MkDocs GitHub Action","text":"<p>An automated workflow that redeploys the MkDocs site to GitHub Pages every time a new commit is pushed to the <code>main</code> branch.</p>"},{"location":"references/#microchip-pic24fj64ga002-datasheet","title":"Microchip PIC24FJ64GA002 Datasheet","text":"<p>The official datasheet from Microchip was used throughout the book for referencing registers, configuration bits, and peripheral behavior.</p>"},{"location":"references/#visual-studio-code-vs-code","title":"Visual Studio Code (VS Code)","text":"<p>The primary development environment for editing Markdown files, YAML configurations, and managing version control through Git.</p>"},{"location":"references/#conda","title":"Conda","text":"<p>Used to manage Python environments and dependencies (like <code>mkdocs-material</code>) for consistent local development and previewing.</p>"},{"location":"references/#markdown-paste-vs-code-extension","title":"Markdown Paste (VS Code Extension)","text":"<p>A helpful extension used to quickly insert and format images into Markdown files, streamlining the content creation process.</p>"},{"location":"references/#intelligent-textbook-examples","title":"Intelligent Textbook Examples","text":"<p>Inspired by previous intelligent textbook projects that combine Markdown-based authoring with AI-generated content and embedded learning tools.</p>"},{"location":"toc/","title":"Table of Contents","text":"<p>Below is a high-level overview of the chapters, tutorials, prompts, glossary, and simulations included in this intelligent textbook.</p>"},{"location":"toc/#chapters","title":"Chapters","text":"<ul> <li>Chapter 1: Introduction to Microcontrollers</li> <li>Chapter 2: Assembly &amp; Syntax</li> <li>Chapter 3: Branching &amp; Loops</li> <li>Chapter 4: Stack &amp; Subroutines</li> <li>Chapter 5: Timers &amp; Interrupts</li> <li>Chapter 6: External Interrupts &amp; Input Capture</li> <li>Chapter 7: Output Compare &amp; PWM</li> <li>Chapter 8: Communication &amp; Peripherals</li> </ul>"},{"location":"toc/#microsimulations","title":"MicroSimulations","text":"<ul> <li>Stack Visualizer</li> <li>Timer Interrupt Simulator</li> <li>PWM Waveform Generator</li> <li>Input Capture Simulator</li> <li>ADC Visualizer</li> <li>GPIO Setup Simulator (TRIS/LAT/AD1PCFG)</li> <li>Register Operation Simulator</li> <li>Branch Loop Counter Simulator</li> <li>Serial Communication Overview (UART, SPI, I2C)</li> </ul>"},{"location":"toc/#additional-pages","title":"Additional Pages","text":"<ul> <li>Glossary</li> <li>Course Description</li> <li>References</li> <li>Contact</li> <li>How We Built This Site</li> </ul>"},{"location":"chapters/","title":"Welcome to My MkDocs Site","text":""},{"location":"chapters/chapter-1/","title":"Chapter 1: Introduction to Microcontrollers &amp; PIC24FJ64GA002","text":""},{"location":"chapters/chapter-1/#section-1-what-is-a-microcontroller","title":"Section 1: What is a Microcontroller?","text":"<p>A microcontroller is a compact, self-contained computer system built onto a single integrated circuit. It includes:</p> <ul> <li>A CPU (Central Processing Unit)</li> <li>Memory (Flash and RAM)</li> <li>A set of peripherals (I/O ports, timers, ADCs, serial comms)</li> </ul> <p>These components allow the microcontroller to interact with the real world \u2014 sensing, computing, and controlling things like motors, lights, sensors, and displays.</p>"},{"location":"chapters/chapter-1/#microcontroller-block-diagram","title":"Microcontroller Block Diagram","text":"<p>The diagram below shows a typical microcontroller architecture.</p> <p> </p> <p>As shown: - The CPU communicates with peripherals through buses - Modules like UART, SPI, ADC, and timers are all built-in - Flash stores the program, and RAM stores runtime variables</p> <p>Unlike general-purpose computers, microcontrollers are built for dedicated control tasks \u2014 not multitasking or user interaction.</p>"},{"location":"chapters/chapter-1/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>\ud83d\udd39 Small footprint: Ideal for embedded systems with limited space</li> <li>\ud83d\udd39 Real-time responsiveness: Handles time-sensitive tasks predictably</li> <li>\ud83d\udd39 Integrated I/O: No need for external chips to communicate</li> <li>\ud83d\udd39 Low power: Great for battery-powered devices</li> <li>\ud83d\udd39 Cost-effective: Perfect for mass production and consumer products</li> </ul> <p>Microcontrollers are the foundation of most embedded systems \u2014 from smart home devices to industrial automation.</p>"},{"location":"chapters/chapter-1/#section-2-overview-of-the-pic24fj64ga002","title":"Section 2: Overview of the PIC24FJ64GA002","text":"<p>For this textbook, we\u2019ll be working with the PIC24FJ64GA002, a 16-bit microcontroller developed by Microchip.</p> <p>This device strikes a great balance between simplicity and power \u2014 making it ideal for students and embedded systems developers alike.</p>"},{"location":"chapters/chapter-1/#key-features","title":"Key Features","text":"Feature Value Core 16-bit modified Harvard Clock Speed Up to 32 MHz Program Flash 64 KB RAM 8 KB I/O Pins 21 Timers 5 (16-bit and 32-bit capable) ADC Channels 10-bit, 13 input channels UART / SPI / I2C 2 UARTs, 2 SPI, 1 I2C <p>Datasheet Reference: PIC24FJ64GA002 Datasheet (Microchip)</p>"},{"location":"chapters/chapter-1/#why-this-chip","title":"Why This Chip?","text":"<ul> <li>Widely supported in MPLAB X IDE and the XC16 compiler</li> <li>Features common peripherals used in real-world systems</li> <li>Has enough complexity to teach important concepts without being overwhelming</li> <li>Low-cost and easy to prototype with (available on dev boards)</li> </ul> <p>You\u2019ll see this microcontroller referenced throughout the book \u2014 from I/O programming to advanced peripheral control.</p>"},{"location":"chapters/chapter-1/#section-3-the-development-environment","title":"Section 3: The Development Environment","text":"<p>To write, compile, and test code for the PIC24FJ64GA002, we use Microchip\u2019s official toolchain:</p>"},{"location":"chapters/chapter-1/#mplab-x-ide","title":"MPLAB X IDE","text":"<p>MPLAB X is an Integrated Development Environment (IDE) that supports Microchip\u2019s entire family of devices, including PIC24.</p> <ul> <li>Features project management, code editing, and debugger integration</li> <li>Runs on Windows, macOS, and Linux</li> <li>Allows simulation, breakpoints, memory inspection, and more</li> </ul> <p>Download: MPLAB X IDE \u2013 Microchip</p>"},{"location":"chapters/chapter-1/#xc16-compiler","title":"XC16 Compiler","text":"<p>Microchip\u2019s XC16 is a C compiler tailored for 16-bit devices like the PIC24 family.</p> <ul> <li>Converts your C code into binary <code>.hex</code> files for flashing</li> <li>Works directly inside MPLAB X</li> <li>Supports optimization levels for size, speed, and debugging</li> </ul> <p>In this book, we\u2019ll stick to C and inline assembly where needed \u2014 all compiled using XC16.</p>"},{"location":"chapters/chapter-1/#simulators-and-debuggers","title":"Simulators and Debuggers","text":"<p>You can: - Simulate logic (LEDs, registers, timing) using MPLAB\u2019s built-in simulator - Flash code to real hardware using tools like PICkit 3/4 or Curiosity boards</p> <p>Later in this book, we\u2019ll introduce MicroSims \u2014 small, interactive simulations designed to visualize how code affects hardware behavior.</p> <p>With this toolchain installed, you're ready to start building and debugging embedded systems with confidence.</p>"},{"location":"chapters/chapter-1/#section-4-embedded-vs-general-purpose-programming","title":"Section 4: Embedded vs General-Purpose Programming","text":"<p>Programming a microcontroller is very different from writing software for a desktop or smartphone.</p> <p>While general-purpose computers focus on speed, user interaction, and multitasking, embedded systems are designed for deterministic control of hardware \u2014 often under tight resource constraints.</p>"},{"location":"chapters/chapter-1/#general-purpose-programming-eg-python-java","title":"General-Purpose Programming (e.g., Python, Java)","text":"<ul> <li>Focus on user experience and abstraction</li> <li>Often use operating systems for multitasking and memory management</li> <li>Can be inefficient \u2014 memory and CPU are plentiful</li> </ul>"},{"location":"chapters/chapter-1/#embedded-programming-eg-c-assembly","title":"Embedded Programming (e.g., C, Assembly)","text":"<ul> <li>Runs bare-metal or with minimal OS support</li> <li>Must manage timing, memory, and power directly</li> <li>Designed for real-world interaction: controlling motors, reading sensors, etc.</li> <li>Emphasis on efficiency and predictability</li> </ul> Concept Embedded Systems General-Purpose Systems Environment Real-time, resource-constrained OS-managed, multi-user Timing Deterministic, cycle-aware Flexible, best-effort Language C / Assembly Java, Python, C# Use Cases Thermostats, robots, sensors Web apps, spreadsheets, games <p>In embedded systems, a missed deadline or unexpected delay can cause system failure \u2014 timing is everything.</p> <p>Throughout this textbook, we\u2019ll write tight, predictable C and assembly code that gives us precise control over the hardware.</p>"},{"location":"chapters/chapter-1/#section-5-configuring-digital-io-pins-on-the-pic24","title":"Section 5: Configuring Digital I/O Pins on the PIC24","text":"<p>Before using a microcontroller pin as a digital output, it must be correctly configured. On the PIC24, three important registers control this:</p> Register Purpose TRISx Sets the pin direction: 1 = Input, 0 = Output LATx Holds the output value for the pin: 1 = High, 0 = Low AD1PCFG Selects digital or analog mode: 1 = Digital, 0 = Analog"},{"location":"chapters/chapter-1/#typical-setup-for-digital-output","title":"\ud83d\udd39 Typical Setup for Digital Output:","text":"<ol> <li>Configure TRISx bit to 0 \u2192 set pin as output</li> <li>Set AD1PCFG bit to 1 \u2192 disable analog input (ensure digital function)</li> <li>Control LATx bit \u2192 drive output high or low</li> </ol> <p>If any step is missed, the pin might behave unexpectedly (e.g., float, stay analog, or refuse to drive an output).</p>"},{"location":"chapters/chapter-1/#interactive-microsim-digital-output-pin-configurator","title":"Interactive MicroSim: Digital Output Pin Configurator","text":"<p>To better understand how PIC24 pins are configured for digital output, interact with the MicroSim below.  </p> <p>\ud83d\udc49 Launch the Pin Configuration Simulation</p> <p>Experiment with the <code>TRIS</code>, <code>AD1PCFG</code>, and <code>LAT</code> settings to see how they affect the final pin state.</p>"},{"location":"chapters/chapter-1/#section-6-summary-and-use-cases","title":"Section 6: Summary and Use Cases","text":"<p>Let\u2019s review the key points from this chapter:</p>"},{"location":"chapters/chapter-1/#core-ideas","title":"Core Ideas","text":"<ul> <li>A microcontroller is a self-contained system with a CPU, memory, and peripherals built into one chip</li> <li>The PIC24FJ64GA002 is a 16-bit MCU with timers, ADCs, communication modules, and 64 KB of Flash</li> <li>Development is done using MPLAB X IDE and the XC16 compiler</li> <li>Embedded programming focuses on predictability, efficiency, and hardware interaction</li> </ul>"},{"location":"chapters/chapter-1/#where-are-microcontrollers-used","title":"Where Are Microcontrollers Used?","text":"Use Case Example Devices Consumer Electronics Thermostats, smart watches, toys Automotive Airbags, ABS controllers, key fobs Industrial Automation Motor drivers, temperature sensors Medical Devices Heart monitors, insulin pumps Robotics &amp; Prototyping Line-following robots, drones <p>As you go through this book, you\u2019ll develop the low-level control skills that make these devices possible \u2014 starting from the very first line of assembly code.</p>"},{"location":"chapters/chapter-1/#quiz-microcontroller-fundamentals","title":"Quiz: Microcontroller Fundamentals","text":"<p>Which of the following is true about microcontrollers?</p> <ol> <li>They require an operating system to function  </li> <li>They are mainly used for high-performance graphics  </li> <li>They integrate a CPU, memory, and peripherals on one chip  </li> <li>They must be connected to the internet to work  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>Microcontrollers are self-contained systems with a CPU, RAM, Flash, and I/O peripherals \u2014 all integrated onto one chip. They are designed for dedicated, low-power control tasks, not general-purpose computing.</p>"},{"location":"chapters/chapter-1/#prompt-practice","title":"Prompt Practice","text":"<p>Think of an everyday device that uses a microcontroller (e.g., microwave, car key fob, thermostat). How might that microcontroller interact with the real world?</p> <p>Write a short description answering the following:</p> <ul> <li>What is the microcontroller sensing?</li> <li>What outputs or devices does it control?</li> <li>Why is a microcontroller useful in this case?</li> </ul> Click to show example <p>Smart Thermostat</p> <ul> <li>Senses room temperature using a digital temperature sensor  </li> <li>Controls the HVAC system by turning heating/cooling on or off  </li> <li>Microcontroller use: Performs decisions based on user input and sensor data. Communicates with Wi-Fi to support remote control.</li> </ul>"},{"location":"chapters/chapter-2/","title":"Chapter 2: Assembly &amp; Addressing Modes","text":""},{"location":"chapters/chapter-2/#section-1-why-learn-assembly","title":"Section 1: Why Learn Assembly?","text":"<p>Modern embedded systems are often programmed in high-level languages like C, but understanding assembly language is crucial for writing efficient, low-level code and truly mastering how a microcontroller works.</p> <p>Assembly gives you:</p> <ul> <li>Complete control over the CPU, memory, and peripheral access</li> <li>Performance optimizations that compilers can't always guarantee</li> <li>A deep understanding of what C code is actually doing \"under the hood\"</li> <li>The ability to debug complex timing or hardware interaction issues</li> </ul> <p>Most high-level code on microcontrollers is eventually compiled into assembly \u2014 learning how to read and write it directly unlocks a new level of skill and insight.</p>"},{"location":"chapters/chapter-2/#pic24-assembly-basics","title":"PIC24 Assembly Basics","text":"<p>The PIC24 family uses a RISC (Reduced Instruction Set Computing) assembly language with a 16-bit word size. Each instruction typically executes in one cycle (excluding branching or memory fetches).</p> <p>In this chapter, we\u2019ll explore: - The basic syntax of PIC24 assembly - How data is moved between memory and registers - The different addressing modes (immediate, direct, indirect) - How to perform arithmetic and logical operations</p>"},{"location":"chapters/chapter-2/#section-2-basic-instruction-structure-syntax","title":"Section 2: Basic Instruction Structure &amp; Syntax","text":"<p>Assembly instructions for the PIC24 follow a clear, consistent pattern:</p> <pre><code>OPCODE  OPERAND1, OPERAND2\n</code></pre> <p>Where:</p> <ul> <li>OPCODE: The operation to perform (e.g., <code>MOV</code>, <code>ADD</code>, <code>SUB</code>)</li> <li>OPERAND1: The source (where the data comes from)</li> <li>OPERAND2: The destination (where the result is stored)</li> </ul>"},{"location":"chapters/chapter-2/#example-moving-data","title":"Example: Moving Data","text":"<pre><code>MOV     W1, W0      ; Copy contents of W1 into W0\nMOV     #10, W2     ; Load the literal value 10 into W2\n</code></pre> <ul> <li>In <code>MOV W1, W0</code>, the value in <code>W1</code> is copied into <code>W0</code></li> <li>In <code>MOV #10, W2</code>, the literal value 10 is loaded into <code>W2</code></li> </ul>"},{"location":"chapters/chapter-2/#commenting-your-code","title":"Commenting Your Code","text":"<p>Use semicolons (<code>;</code>) to add inline comments:</p> <pre><code>CLR     W3          ; Clear register W3\nADD     W1, W2      ; Add W1 to W2 (result stored in W2)\n</code></pre> <p>In PIC24 assembly, instructions often modify the second operand \u2014 the destination \u2014 directly.</p>"},{"location":"chapters/chapter-2/#section-3-working-registers-w0w15","title":"Section 3: Working Registers (W0\u2013W15)","text":"<p>The PIC24 has 16 general-purpose working registers, labeled <code>W0</code> through <code>W15</code>.</p> <p>These are used in most instructions for arithmetic, logic, data movement, and memory access.</p>"},{"location":"chapters/chapter-2/#what-are-working-registers","title":"What Are Working Registers?","text":"<p>Working registers are fast-access memory locations inside the CPU. They're used to:</p> <ul> <li>Perform calculations (<code>ADD</code>, <code>SUB</code>, <code>MUL</code>)</li> <li>Pass function arguments</li> <li>Store temporary values</li> <li>Hold addresses for memory access</li> </ul>"},{"location":"chapters/chapter-2/#common-usage","title":"Common Usage","text":"Register Role Notes W0\u2013W13 General-purpose Can be used freely W14 Frame Pointer (FP) Often used for accessing stack frames W15 Stack Pointer (SP) Always points to the top of the stack <p>Unlike high-level variables, working registers are not named \u2014 you must track their purpose as you code.</p>"},{"location":"chapters/chapter-2/#example","title":"Example","text":"<pre><code>MOV     #42, W1       ; Load literal 42 into W1\nMOV     #8,  W2       ; Load literal 8 into W2\nADD     W1, W2        ; W2 = W1 + W2 \u2192 result in W2\n</code></pre> <p>W1 and W2 now contain temporary values and the result of an operation \u2014 all without using main memory.</p>"},{"location":"chapters/chapter-2/#section-4-addressing-modes-in-pic24","title":"Section 4: Addressing Modes in PIC24","text":"<p>Addressing modes define how operands are accessed in an instruction. PIC24 supports multiple flexible modes that give you precise control over data retrieval.</p>"},{"location":"chapters/chapter-2/#1-immediate-addressing","title":"1. Immediate Addressing","text":"<p>Use a literal constant directly in the instruction.</p> <pre><code>MOV     #25, W0      ; Load the value 25 into W0\n</code></pre> <p><code>#25</code> is a literal constant. Useful for setting values or initializing registers.</p>"},{"location":"chapters/chapter-2/#2-register-direct","title":"2. Register Direct","text":"<p>Use the value stored in a working register.</p> <pre><code>MOV     W1, W2       ; Copy contents of W1 into W2\n</code></pre> <p>Fastest mode \u2014 all operations using <code>Wn</code> fall under this category.</p>"},{"location":"chapters/chapter-2/#3-register-indirect","title":"3. Register Indirect","text":"<p>Treat the contents of a register as a pointer to a memory address.</p> <pre><code>MOV     [W5], W0     ; Move value from memory pointed to by W5 into W0\n</code></pre> <p>W5 holds the address, not the value. This accesses memory indirectly.</p>"},{"location":"chapters/chapter-2/#4-indirect-with-post-increment","title":"4. Indirect with Post-Increment","text":"<p>Automatically increments the pointer after the access.</p> <pre><code>MOV     [W6++], W1   ; W1 = *W6, then W6 = W6 + 2\n</code></pre> <p>Ideal for traversing arrays. Increments by 2 bytes (since PIC24 uses 16-bit words).</p>"},{"location":"chapters/chapter-2/#5-indirect-with-pre-decrement","title":"5. Indirect with Pre-Decrement","text":"<p>Decrements the pointer before the access.</p> <pre><code>MOV     [--W6], W1   ; W6 = W6 - 2, then move from new address into W1\n</code></pre> <p>Common when accessing stack values in reverse order.</p>"},{"location":"chapters/chapter-2/#6-literal-offset-register-indexed","title":"6. Literal Offset + Register (Indexed)","text":"<p>Adds a literal offset to a base register.</p> <pre><code>MOV     [W8 + 4], W0   ; Move from address (W8 + 4) into W0\n</code></pre> <p>Useful for arrays and structs. Offset must be word-aligned (multiple of 2).</p> <p>Understanding addressing modes is essential for writing flexible and efficient assembly code.</p>"},{"location":"chapters/chapter-2/#interactive-microsim-register-instruction-simulator","title":"Interactive MicroSim: Register Instruction Simulator","text":"<p>Practice manipulating working registers (<code>W0</code>\u2013<code>W5</code>) using simple PIC24 assembly-style instructions.</p> <p>\ud83d\udc49 Launch the Register Instruction Simulator</p>"},{"location":"chapters/chapter-2/#example-instructions","title":"Example Instructions:","text":"<pre><code>MOV     #10, W0     ; Load literal 10 into W0\nMOV     W0, W1      ; Copy W0 into W1\nADD     W1, W0      ; W0 = W0 + W1\nADD     #5, W2      ; W2 = W2 + 5\nSUB     W1, W0      ; W0 = W0 - W1\nCLR     W2          ; Clear W2 (set to 0)\n\n\n## Section 5: Writing Clean, Readable Assembly\n\nWriting assembly that works is good. Writing assembly that others (and future you) can understand? Even better.\n\nHere are a few **best practices** for clean and maintainable PIC24 assembly:\n\n---\n\n### Use Labels Effectively\n\nLabels are like **named bookmarks** in your code. They make loops and branches much easier to follow.\n\n```asm\nLoop:\n    DEC     W0, W0\n    CP      W0, #0\n    BNE     Loop     ; Branch if W0 \u2260 0\n</code></pre> <p>Always place labels on their own line for clarity.</p>"},{"location":"chapters/chapter-2/#comment-generously","title":"Comment Generously","text":"<p>Every line of code should communicate intent, not just function.</p> <pre><code>MOV     #10, W1      ; Load loop count\nMOV     #0,  W2      ; Clear sum accumulator\n</code></pre> <p>Write your comments for beginners \u2014 not just experts.</p>"},{"location":"chapters/chapter-2/#align-instructions","title":"Align Instructions","text":"<p>Neatly aligned code is easier to scan and debug.</p> <pre><code>MOV     #3,  W0\nADD     W1,  W0\nCP      W0,  #5\n</code></pre> <p>Consistent spacing makes your code look professional and polished.</p>"},{"location":"chapters/chapter-2/#use-nop-for-debugging","title":"Use <code>NOP</code> for Debugging","text":"<pre><code>NOP                 ; No operation \u2013 useful for breakpoints\n</code></pre> <p>NOPs help pause execution at specific lines during simulation or hardware debugging.</p> <p>Clean code isn\u2019t about cleverness \u2014 it\u2019s about clarity. Good formatting makes bugs easier to catch and logic easier to follow.</p>"},{"location":"chapters/chapter-2/#section-6-summary-and-instruction-cheat-sheet","title":"Section 6: Summary and Instruction Cheat Sheet","text":"<p>By now, you\u2019ve seen how assembly gives you precise, low-level control over your microcontroller.</p>"},{"location":"chapters/chapter-2/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>PIC24 instructions follow the format: <code>OPCODE OPERAND1, OPERAND2</code></li> <li><code>W0\u2013W15</code> are working registers used for calculations and memory access</li> <li>Addressing modes allow you to work with constants, registers, and memory</li> <li>Good formatting and comments make your code readable and debuggable</li> </ul>"},{"location":"chapters/chapter-2/#common-pic24-assembly-instructions","title":"Common PIC24 Assembly Instructions","text":"Instruction Description <code>MOV</code> Move data between registers or from a literal <code>ADD</code> Add two values <code>SUB</code> Subtract one value from another <code>CLR</code> Clear a register (set to 0) <code>INC</code>/<code>DEC</code> Increment or decrement a register <code>CP</code> Compare values (used with conditional branches)"},{"location":"chapters/chapter-2/#working-register-reference","title":"Working Register Reference","text":"Register Purpose <code>W0\u2013W13</code> General-purpose registers <code>W14</code> Frame pointer (optional) <code>W15</code> Stack pointer (must not modify manually) <p>Understanding these fundamentals will help you as we begin writing actual control logic, loops, and subroutines in the next chapter.</p>"},{"location":"chapters/chapter-2/#quiz-assembly-fundamentals","title":"Quiz: Assembly Fundamentals","text":"<p>What does the following instruction do?</p> <pre><code>MOV     W2, W1\n</code></pre> <ol> <li>W2 becomes equal to W1  </li> <li>W1 becomes equal to W2  </li> <li>W2 and W1 are cleared  </li> <li>Nothing happens  </li> </ol> Show Answer <p>The correct answer is B.</p> <p><code>MOV W2, W1</code> takes the contents of <code>W2</code> and copies them into <code>W1</code>. The original value in <code>W1</code> is overwritten.</p>"},{"location":"chapters/chapter-2/#prompt-practice","title":"Prompt Practice","text":"<p>Write a short assembly routine that: - Loads the values 5 and 10 into two registers - Adds them together - Stores the result in a third register</p> <p>Try to write it yourself first, then reveal the answer below.</p> Click to show solution <pre><code>MOV     #5,  W0      ; Load 5 into W0\nMOV     #10, W1      ; Load 10 into W1\nADD     W0,  W1      ; W1 = W0 + W1 \u2192 result in W1\nMOV     W1,  W2      ; Copy result into W2\n</code></pre>"},{"location":"chapters/chapter-3/","title":"Chapter 3: Branching &amp; Loops in Assembly","text":""},{"location":"chapters/chapter-3/#section-1-controlling-the-flow-of-execution","title":"Section 1: Controlling the Flow of Execution","text":"<p>Until now, we\u2019ve written assembly code that executes linearly \u2014 one instruction after another from top to bottom. But real programs rarely follow a straight path. They make decisions, repeat tasks, and jump between sections of code.</p> <p>To do this in assembly, we use:</p> <ul> <li>Branching to jump to different parts of the code</li> <li>Conditional instructions to decide when to branch</li> <li>Loops to repeat actions until a condition is met</li> </ul> <p>Just like in higher-level languages (<code>if</code>, <code>while</code>, <code>for</code>), branching and looping let us create flexible, reactive, and dynamic programs \u2014 but we build them manually in assembly using a combination of labels, comparison instructions, and branch instructions.</p>"},{"location":"chapters/chapter-3/#real-world-example-polling-a-button","title":"Real-World Example: Polling a Button","text":"<p>Let\u2019s say you want your microcontroller to wait until a button is pressed, and then turn on an LED. That requires:</p> <ul> <li>Repeatedly checking a pin (a loop)</li> <li>Branching based on whether the pin is high or low (a decision)</li> </ul> <p>In assembly, that logic would look like:</p> <p><pre><code>CheckButton:\n    MOV     PORTB, W0         ; Load PORTB into W0\n    AND     W0, #0x0001, W0   ; Mask all but bit 0 (RB0)\n    CP      W0, #0            ; Is RB0 low?\n    BEQ     CheckButton       ; If yes, button not pressed \u2192 loop back\n\n    BSET    LATB, #1          ; Set RB1 (turn on LED)\n</code></pre> This example shows both a loop(keep checking) and a branch(skip ahead once the button is pressed)</p> <p>Avoid using <code>INC LATB</code> or <code>ADD LATB, #value</code></p> <p>These instructions modify the entire 16-bit latch, which can unintentionally affect multiple output pins. For example:</p> <ul> <li>If only RB1 should be set, <code>INC</code> might toggle RB0 or clear RB1 depending on the current value.</li> <li>Using arithmetic operations doesn\u2019t preserve the state of other bits.</li> </ul>"},{"location":"chapters/chapter-3/#section-2-unconditional-branching","title":"Section 2: Unconditional Branching","text":"<p>In assembly, unconditional branching allows you to jump to another part of your program without checking any condition. It\u2019s like saying, \u201cGo here, no matter what.\u201d</p> <p>This is useful for:</p> <ul> <li>Skipping over code</li> <li>Repeating a block (with labels)</li> <li>Structuring loops</li> <li>Returning to a main loop after an operation</li> </ul>"},{"location":"chapters/chapter-3/#bra-branch-always","title":"\ud83d\udd39 <code>BRA</code> \u2014 Branch Always","text":"<p>The <code>BRA</code> instruction causes the program to jump to a label. Execution continues from that label as if the code above it didn\u2019t exist.</p> <p><pre><code>BRA     MainLoop \n</code></pre> BRA uses relative addressing (i.e. jump a certain number of instruction forward/backward).  A tip for BRA is to use it for most control flow and loops.</p>"},{"location":"chapters/chapter-3/#call-and-return-preview","title":"\ud83d\udd39 <code>Call</code> and <code>Return</code> (Preview)","text":"<p>You can also branch to a subroutine using <code>Call</code>, which saves the current program counter(PC) onto the stack. When the subroutine is done, it uses RETURN to jump back.</p> <pre><code>CALL    DelayLoop    ; Jump to subroutine\nRETURN               ; Return from it\n</code></pre> <p>We'll cover the stack and subroutines more deeply in Chapter 4, so for now just think of <code>CALL</code> as a way to jump to a reusable block of code and RETURN as a way to come back. </p>"},{"location":"chapters/chapter-3/#summary","title":"Summary","text":"Instruction Purpose <code>BRA</code> Unconditional branch (relative) <code>CALL</code> Branch to subroutine (saves return address on stack) <code>RETURN</code> Return from subroutine (restores execution flow)"},{"location":"chapters/chapter-3/#section-3-conditional-branching","title":"Section 3: Conditional Branching","text":"<p>Sometimes, you want to branch only if a condition is true \u2014 like jumping to a section of code only if two values match, or only if a counter hasn\u2019t hit zero yet.</p> <p>To do that, PIC24 uses a two-step process: 1. Compare values using the <code>CP</code> (Compare) instruction 2. Use a conditional branch like <code>BNE</code> or <code>BEQ</code> based on the result</p>"},{"location":"chapters/chapter-3/#step-1-compare-with-cp","title":"\ud83d\udd39 Step 1: Compare with <code>CP</code>","text":"<p>The <code>CP</code> instruction compares two values by internally performing a subtraction (without storing the result). It sets status flags (Zero, Negative, Overflow, etc.) based on the result.</p> <p><pre><code>CP      W0, W1     ; Compare W0 to W1\n</code></pre> After this, the processor knows whether <code>W0 == W1</code>, <code>W0 &lt; W1</code>, or <code>W0 &gt; W1</code></p>"},{"location":"chapters/chapter-3/#step-2-branch-based-on-flags","title":"\ud83d\udd39 Step 2: Branch Based on Flags","text":"<p>Once <code>CP</code> sets the condition flags, you can use one of several conditional branch instructions:</p> Instruction Meaning Condition Tested <code>BEQ</code> Branch if equal Z = 1 (Zero flag) <code>BNE</code> Branch if not equal Z = 0 <code>BLT</code> Branch if less than (signed) N \u2260 V <code>BGE</code> Branch if greater/equal N = V <code>BRA</code> Branch always (no condition) \u2014 <pre><code>CP      W0, #10      ; Compare W0 to literal 10\nBEQ     MatchLabel   ; If W0 == 10, jump to MatchLabel\n    ; This code runs if W0 \u2260 10\n\nMatchLabel:\n    ; This code runs only if W0 == 10\n</code></pre>"},{"location":"chapters/chapter-3/#what-are-condition-flags","title":"What Are Condition Flags?","text":"<p>When the PIC24 performs a compare, it updates specific bits in the Status Register (SR):</p> <ul> <li>Z (Zero): Set if the result is zero (values matched)  </li> <li>N (Negative): Set if result was negative  </li> <li>C (Carry) and V (Overflow): Used in signed/unsigned comparisons  </li> </ul> <p>These flags are not written directly by your code \u2014 they\u2019re set automatically by instructions like <code>CP</code>, <code>SUB</code>, or <code>ADD</code>.</p>"},{"location":"chapters/chapter-3/#section-4-loops-in-assembly","title":"Section 4: Loops in Assembly","text":"<p>Loops are a fundamental programming structure that let you repeat code until a condition is met. In high-level languages, we use constructs like <code>for</code> or <code>while</code>. In assembly, we build loops manually using:</p> <ul> <li>A label to mark the start of the loop</li> <li>A comparison (<code>CP</code>)</li> <li>A conditional branch (<code>BNE</code>, <code>BEQ</code>, etc.)</li> </ul>"},{"location":"chapters/chapter-3/#counting-down-example","title":"\ud83d\udd39 Counting Down Example","text":"<p>This loop counts from 3 down to 0 and stops when the counter reaches zero:</p> <p><pre><code>    MOV     #3, W0         ; Initialize counter to 3\n\nLoopStart:\n    ; [Insert code you want to repeat here]\n\n    DEC     W0, W0         ; Decrement counter\n    CP      W0, #0         ; Is counter zero?\n    BNE     LoopStart      ; If not, repeat loop\n</code></pre> This loop executes 3 times with W0 values: 2, 1, 0</p>"},{"location":"chapters/chapter-3/#counting-up-example","title":"\ud83d\udd39 Counting Up Example","text":"<p>If you want to count up instead:</p> <pre><code>    MOV     #0, W0         ; Start at 0\n\nLoopStart:\n    ; [Repeat logic here]\n\n    INC     W0, W0         ; Increment counter\n    CP      W0, #4         ; Stop when W0 reaches 4\n    BNE     LoopStart\n</code></pre> <p>This runs the loop while W0 = 0,1,2,3 - a total of 4 iterations.</p>"},{"location":"chapters/chapter-3/#why-assembly-loops-require-manual-control","title":"\ud83d\udd39 Why Assembly Loops Require Manual Control","text":"<p>Unlike C or Python, assembly doesn\u2019t have <code>while</code>, <code>for</code>, or <code>do...while</code> built in. But using just a few instructions, you can build any loop structure:</p> High-Level Idea Assembly Equivalent <code>while (x != 0)</code> label + <code>CP</code> + <code>BNE</code> <code>for (i = 0; i &lt; 4; i++)</code> <code>MOV</code> + label + <code>INC</code> + <code>CP</code> + <code>BNE</code> Infinite loop label + <code>BRA label</code>"},{"location":"chapters/chapter-3/#looping-summary","title":"Looping Summary:","text":"<ul> <li>Loops require a counter, a label, a comparison, and a branch.</li> <li><code>BNE</code> is commonly used to repeat while not equal to a target.</li> <li>You can loop upward, downward, or infinitely depending on the logic.</li> <li>Assembly loops give you full control, but also require more careful setup.</li> </ul>"},{"location":"chapters/chapter-3/#section-5-labeling-and-structure-tips","title":"Section 5: Labeling and Structure Tips","text":"<p>In assembly programming, labels are used to name a location in code that you can jump to using <code>BRA</code>, <code>CALL</code>, or conditional branches.</p> <p>They\u2019re the foundation for loops, subroutines, and organizing non-linear control flow.</p>"},{"location":"chapters/chapter-3/#defining-and-using-labels","title":"\ud83d\udd39 Defining and Using Labels","text":"<p>A label is a name followed by a colon <code>:</code>. It marks a position in your program.</p> <p><pre><code>Start:\n    MOV     #3, W0\n    BRA     Start         ; Jumps back to Start\n</code></pre> You can branch to a label anywhere in your program - forward or backward.</p>"},{"location":"chapters/chapter-3/#good-labeling-habits","title":"Good Labeling Habits","text":"<p>To keep your code readable and maintainable, follow these practices: </p> <ul> <li> <p>Use descriptive names   \u2192 e.g., <code>LoopStart</code>, <code>CheckDone</code>, <code>RetryLimit</code> \u2014 avoid generic labels like <code>L1</code>, <code>L2</code></p> </li> <li> <p>Align labels to the left margin   \u2192 Makes them easy to see when scanning your code</p> </li> <li> <p>Indent instructions beneath labels   \u2192 Improves visual clarity and shows structure</p> </li> <li> <p>Choose a consistent style   \u2192 Capitalized (<code>WAIT_LOOP:</code>) or camelCase (<code>waitLoop:</code>), just keep it uniform</p> </li> <li> <p>Use <code>NOP</code> for debugging or timing padding   \u2192 Safe spot for breakpoints or delay without affecting program logic</p> </li> </ul>"},{"location":"chapters/chapter-3/#using-nop-for-debugging","title":"Using <code>NOP</code> for Debugging","text":"<p>The <code>NOP</code> instruction (\"No Operation) does nothing - it simply consumes a clock cycle.</p> <p>It's useful for: </p> <ul> <li>Setting breakpoints during debugging</li> <li>Adding timing delays (in loops)</li> <li>Temporarily padding out code to preserve layout</li> </ul> <pre><code>NOP     ; Do nothing - can be a good place to break in debugger\n</code></pre>"},{"location":"chapters/chapter-3/#why-structure-matters","title":"Why Structure Matters","text":"<p>Assembly doesn\u2019t give you much abstraction \u2014 so clarity is your responsibility. Clean labels, indentation, and comments go a long way in making your code understandable \u2014 especially when debugging or returning to it later.</p>"},{"location":"chapters/chapter-3/#interactive-simulation","title":"Interactive Simulation","text":"<p>Want to see how loop control flows behave step by step?</p> <p>\ud83d\udc49 Try the Loop Flow Visualizer MicroSim</p> <p>This simulation lets you follow <code>DEC</code>, <code>CP</code>, and <code>BNE</code> instructions visually \u2014 with live register tracking, branching highlights, and total loop iteration count!</p>"},{"location":"chapters/chapter-3/#test-your-understanding","title":"Test Your Understanding","text":"<p>Let\u2019s check your grasp of conditional branching and loops with a quick question.</p>"},{"location":"chapters/chapter-3/#quiz-how-many-times-does-the-loop-run","title":"Quiz: How Many Times Does the Loop Run?","text":"<pre><code>MOV     #4, W0\nLoop:\n    DEC     W0, W0\n    CP      W0, #0\n    BNE     Loop\n</code></pre> <ol> <li>3  </li> <li>4  </li> <li>5  </li> <li>Infinite loop  </li> </ol> Show Answer <p>The correct answer is B (4).</p> <p>The loop runs as W0 takes the values: 3, 2, 1, 0 \u2014 which is 4 total iterations. After the final decrement to 0, <code>BNE</code> no longer branches.</p>"},{"location":"chapters/chapter-3/#prompt-practice","title":"Prompt Practice","text":"<p>Can you write a loop that counts from 0 to 3, storing each value to memory?</p> <p>Try to solve it yourself before expanding the answer below!</p> Click to show solution <p>```asm MOV     #0, W0           ; Initialize counter to 0 MOV     #addr, W1        ; Assume W1 holds base address of memory</p> <p>Loop:     MOV     W0, [W1]         ; Store current value at [W1]     INC     W0, W0     ADD     #2, W1, W1       ; Move to next memory location (word = 2 bytes)     CP      W0, #4     BNE     Loop             ; Repeat until W0 == 4     ```</p> <pre><code>This loop stores the values 0, 1, 2, 3 into consecutive memory locations.\n</code></pre>"},{"location":"chapters/chapter-4/","title":"Chapter 4: Stack and Subroutine Calls","text":""},{"location":"chapters/chapter-4/#section-1-what-is-a-stack","title":"Section 1: What is a Stack?","text":"<p>A stack is a special kind of data structure that operates on a Last In, First Out (LIFO) principle \u2014 the last item you place on the stack is the first one to be removed.</p>"},{"location":"chapters/chapter-4/#real-world-analogy","title":"Real-World Analogy","text":"<p>Think of a stack of plates in a cafeteria: - You push a clean plate on top of the pile - You pop the top plate off when someone takes one - You can't grab a plate from the middle \u2014 only the top!</p> <p>This \"top-first\" behavior is exactly how the stack works in your microcontroller.</p>"},{"location":"chapters/chapter-4/#why-do-we-need-a-stack","title":"Why Do We Need a Stack?","text":"<p>Stacks are used any time the program needs to pause what it's doing, remember something, and come back to it later.</p> <p>In the PIC24, the stack is used to: - Store the return address when calling a subroutine - Temporarily hold register values during nested function calls - Save context during interrupts</p> <p>If you didn't have a stack, calling one function from another \u2014 or returning from an interrupt \u2014 would be extremely difficult (if not impossible) to manage.</p>"},{"location":"chapters/chapter-4/#key-operations","title":"Key Operations","text":"Term Meaning <code>PUSH</code> Store a value on the top of the stack <code>POP</code> Remove the top value from the stack <code>CALL</code> Push return address, jump to subroutine <code>RETURN</code> Pop return address, continue execution <p>These operations are handled automatically during function calls \u2014 but you can also perform them manually in assembly.</p> <p>In the next section, we'll explore how the PIC24 handles subroutine calls using the stack, and how to trace exactly what happens when a <code>CALL</code> and <code>RETURN</code> are executed.</p>"},{"location":"chapters/chapter-4/#section-2-the-call-stack-in-assembly","title":"Section 2: The Call Stack in Assembly","text":"<p>Whenever your program executes a subroutine call, the processor must remember where to return after the subroutine finishes. To do this, it uses the stack.</p>"},{"location":"chapters/chapter-4/#what-happens-during-a-call","title":"\ud83d\udd39 What Happens During a <code>CALL</code>","text":"<p>When you execute a <code>CALL</code> instruction:</p> <pre><code>CALL    MyFunction\n</code></pre> <p>The pic 24 automatically performs the following:   - Pushes the return address onto the stack.   - Jumps to the MyFunction label.</p> <p>Later when the subroutine finishes, a <code>RETURN</code> instruction:   - Pops the return address off the stack   - Resumes execution from that address <pre><code>RETURN\n</code></pre></p>"},{"location":"chapters/chapter-4/#stack-behavior-during-function-calls","title":"Stack Behavior During Function Calls","text":"<p>Let's walk through a basic example:</p> <pre><code>Main:\n    CALL    DoSomething\n    ; Execution resumes here after RETURN\n\nDoSomething:\n    ; Function logic here\n    RETURN\n</code></pre> <p>What the Stack Looks Like:</p> Stack Top Contents \u2b06 Growing Downward Address of <code>Main+2</code> (Return to next line)"},{"location":"chapters/chapter-4/#you-dont-have-to-push-return-address-yourself","title":"You Don't Have to Push Return Address Yourself","text":"<p>The best part? You don't need to manually push/pop the return address \u2014 the CALL and RETURN instructions handle it automatically for you. That\u2019s what makes writing subroutines manageable.</p>"},{"location":"chapters/chapter-4/#section-3-stack-pointers-in-the-pic24","title":"Section 3: Stack Pointers in the PIC24","text":"<p>In the PIC24 architecture, the stack is accessed through special-purpose working registers. Understanding these is key to tracing subroutine behavior and building your own call structures.</p>"},{"location":"chapters/chapter-4/#w15-the-stack-pointer-sp","title":"\ud83d\udd39 W15 \u2014 The Stack Pointer (SP)","text":"<p>The register <code>W15</code> is automatically used by the processor as the stack pointer. It always points to the top of the stack in memory.</p> <ul> <li>When you push data, it stores the value at <code>[W15]</code> and increments (post-increment)</li> <li>When you pop data, it decrements first and then reads from <code>[W15]</code> (pre-decrement)</li> </ul>"},{"location":"chapters/chapter-4/#example-manual-pushpop","title":"Example: Manual Push/Pop","text":"<p><pre><code>MOV     #0x1234, W0\nMOV     W0, [W15++]      ; Push W0 onto stack\n\nMOV     [--W15], W1      ; Pop from stack into W1\n</code></pre> You usually don\u2019t need to manipulate W15 directly unless you're saving/restoring temporary values in custom subroutines.</p>"},{"location":"chapters/chapter-4/#w14-the-frame-pointer-optional","title":"\ud83d\udd39 W14 \u2014 The Frame Pointer (Optional)","text":"<p>By convention, <code>W14</code> is often used as a frame pointer, especially in higher-level language support (like C). It can be useful when:</p> <ul> <li>Managing local variables relative to a base offset  </li> <li>Navigating function call frames more easily in complex call chains  </li> </ul> <p>Note: The frame pointer is not required for basic assembly subroutines, but it can help with stack-traceability in deeper projects.</p>"},{"location":"chapters/chapter-4/#summary-of-stack-registers","title":"Summary of Stack Registers","text":"Register Role Usage Example <code>W15</code> Stack Pointer (SP) <code>MOV W0, [W15++]</code> <code>W14</code> Frame Pointer (FP) User-defined (optional)"},{"location":"chapters/chapter-4/#section-4-writing-and-tracing-a-subroutine","title":"Section 4: Writing and Tracing a Subroutine","text":"<p>Let\u2019s bring everything together and write a real subroutine that uses the call stack.</p> <p>We\u2019ll build a function that doubles a value passed in <code>W0</code>, and returns the result in <code>W0</code> \u2014 a simple example, but one that shows how function calls work under the hood.</p>"},{"location":"chapters/chapter-4/#step-1-main-program-calls-the-function","title":"\ud83d\udd39 Step 1: Main Program Calls the Function","text":"<pre><code>    MOV     #7, W0          ; Load 7 into W0\n    CALL    DoubleValue     ; Call subroutine to double W0\n    ; W0 now contains 14\n</code></pre> <p>When <code>CALL DoubleValue</code> is executed, the processor:  - Pushes the return address onto the stack  - Jumps to the label <code>DoubleValue</code></p>"},{"location":"chapters/chapter-4/#step-2-define-the-subroutine","title":"\ud83d\udd39 Step 2: Define the Subroutine","text":"<p><pre><code>DoubleValue:\n    ADD     W0, W0, W0      ; Double the value in W0\n    RETURN                  ; Return to the line after the CALL\n</code></pre> When <code>RETURN</code> executes:  - The processor pops the return address from the stack  - Execution resumes immediately after the <code>CALL</code></p>"},{"location":"chapters/chapter-4/#what-the-stack-looks-like","title":"What the Stack Looks Like","text":"<p>Before <code>CALL DoubleValue</code>, the stack might look like this:</p> Stack Top Contents \u2b06 Growing Downward Address after CALL Return address \u2192 resume here <p>After <code>RETURN</code>, the address is popped off and the stack returns to its previous state.</p>"},{"location":"chapters/chapter-4/#interactive-microsim-stack-tray-visualizer","title":"Interactive MicroSim: Stack Tray Visualizer","text":"<p>To help visualize how function calls and returns interact with the stack, try this MicroSim built on the cafeteria tray analogy.</p> <p>\ud83d\udc49 Try the Stack Tray MicroSim</p> <p>This simulation allows you to:</p> <ul> <li>Press CALL to simulate a function call (tray pushed onto the stack)</li> <li>Press RETURN to simulate a function return (tray popped from the stack)</li> <li>Press RESET to clear the stack</li> </ul> <p>It illustrates how the stack grows and shrinks with each nested function call \u2014 following LIFO (Last In, First Out) behavior.</p>"},{"location":"chapters/chapter-4/#notes","title":"Notes","text":"<ul> <li>The value is passed in <code>W0</code>, and the result is returned in <code>W0</code>. This is a common calling convention for small assembly routines.  </li> <li>For more complex functions, you may also use <code>W1</code>, <code>W2</code>, or the stack itself to pass/return data.</li> </ul>"},{"location":"chapters/chapter-4/#section-5-visualizing-the-stack","title":"Section 5: Visualizing the Stack","text":"<p>Understanding how the stack grows and shrinks is essential for mastering subroutine calls and returns. Even though the processor handles most of the mechanics automatically, being able to mentally trace stack behavior will help you debug and write more reliable code.</p>"},{"location":"chapters/chapter-4/#how-the-stack-grows","title":"\ud83d\udd39 How the Stack Grows","text":"<p>The PIC24 stack grows downward in memory \u2014 that means each time something is pushed, the stack pointer (<code>W15</code>) points to a lower address.</p> <p>Every time you <code>CALL</code> a function:</p> <ul> <li>The return address is pushed onto the stack</li> <li>Any manually saved data (like temporary registers) can also be pushed</li> </ul> <p>When you <code>RETURN</code>:</p> <ul> <li>The return address is popped, and execution resumes where it left off</li> <li>If you saved anything manually, you must also restore it before returning</li> </ul>"},{"location":"chapters/chapter-4/#example-two-nested-calls","title":"Example: Two Nested Calls","text":"<pre><code>Main:\n    CALL    A\n\nA:\n    CALL    B\n    RETURN\n\nB:\n    RETURN\n</code></pre>"},{"location":"chapters/chapter-4/#stack-behavior","title":"Stack Behavior:","text":"<ol> <li><code>CALL A</code> \u2192 pushes return address for <code>Main</code></li> <li>Inside <code>A</code>, <code>CALL B</code> \u2192 pushes return address for <code>A</code></li> <li><code>RETURN</code> from <code>B</code> \u2192 pops to <code>A</code></li> <li><code>RETURN</code> from <code>A</code> \u2192 pops to <code>Main</code></li> </ol>"},{"location":"chapters/chapter-4/#section-6-summary-and-best-practices","title":"Section 6: Summary and Best Practices","text":"<p>Now that you\u2019ve seen how the stack works and how subroutines are built in PIC24 assembly, here\u2019s what you should remember going forward:</p>"},{"location":"chapters/chapter-4/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>The stack stores return addresses (and optionally local data) when calling subroutines.</li> <li><code>CALL</code> and <code>RETURN</code> handle stack push/pop automatically for return addresses.</li> <li><code>W15</code> is the stack pointer (SP) \u2014 it tracks the top of the stack and grows downward.</li> <li><code>W14</code> is commonly used as a frame pointer (FP) \u2014 useful for structured call frames or C-style stack frames.</li> <li>You can manually push/pop data using <code>[W15++]</code> and <code>[--W15]</code>.</li> </ul>"},{"location":"chapters/chapter-4/#best-practices-for-subroutines","title":"Best Practices for Subroutines","text":"<ul> <li>\u2714\ufe0f Use <code>W0</code> to pass parameters and return values in small subroutines.</li> <li>\u2714\ufe0f Use <code>CALL</code>/<code>RETURN</code> for clean function separation.</li> <li>\u2714\ufe0f If you manually push registers (e.g. <code>W1</code>, <code>W2</code>), always restore them before returning.</li> <li>\u274c Avoid modifying <code>W15</code> directly \u2014 use auto-increment/decrement instead.</li> <li>\u2714\ufe0f Keep subroutines small and modular when possible.</li> <li>\u2714\ufe0f Comment your subroutine entry and exit points \u2014 especially when multiple calls are nested.</li> </ul> <p>In the next chapter, we\u2019ll expand your control over time with hardware timers and learn how to build precise time-based behavior in your programs using interrupts.</p>"},{"location":"chapters/chapter-4/#quiz-stack-and-subroutines","title":"Quiz: Stack and Subroutines","text":"<p>What happens to the stack when the following code is executed?</p> <pre><code>    CALL    Func1\n    ; do something\n    CALL    Func2\n    ; done\n\nFunc1:\n    RETURN\n\nFunc2:\n    RETURN\n</code></pre> <ol> <li>The stack is unchanged \u2014 calls don\u2019t affect it  </li> <li>Two values are pushed to the stack and never removed  </li> <li>One return address is pushed and overwritten  </li> <li>Two return addresses are pushed, then popped in reverse order  </li> </ol> Show Answer <p>The correct answer is D.</p> <p>When <code>CALL Func1</code> is executed, the return address is pushed onto the stack. After <code>Func1</code> returns, the address is popped. The same happens with <code>Func2</code>.</p> <p>So, two return addresses are pushed and popped in reverse order \u2014 just like a stack (LIFO).</p>"},{"location":"chapters/chapter-4/#prompt-practice","title":"Prompt Practice","text":"<p>Write a subroutine called <code>AddTen</code> that takes a number in <code>W0</code>, adds 10 to it, and returns the result (also in <code>W0</code>). Your main program should call <code>AddTen</code> with an initial value of <code>5</code>, and store the result in <code>W1</code>.</p> <p>Try writing it yourself before checking the solution!</p> Click to show solution <p>```asm ; Main Program MOV     #5, W0           ; Load value into W0 CALL    AddTen           ; Call subroutine MOV     W0, W1           ; Store result in W1</p> <p>; Subroutine</p> <p>AddTen:     ADD     W0, #10, W0      ; Add 10 to the value in W0     RETURN     ```</p>"},{"location":"chapters/chapter-5/","title":"Chapter 5: Timers and Interrupts","text":""},{"location":"chapters/chapter-5/#section-1-what-are-timers","title":"Section 1: What Are Timers?","text":"<p>Timers are built-in hardware modules that allow the microcontroller to track the passage of time. Unlike using <code>NOP</code> instructions or software loops for delays, hardware timers are far more precise, efficient, and interrupt-friendly.</p>"},{"location":"chapters/chapter-5/#what-timers-actually-do","title":"What Timers Actually Do","text":"<p>At their core, timers are just counters. They increment on each clock cycle (or prescaled clock cycle), and you can configure:</p> <ul> <li>When they start</li> <li>When they reset</li> <li>What value triggers an interrupt or event</li> <li>Whether they count continuously or one time</li> </ul>"},{"location":"chapters/chapter-5/#why-timers-matter","title":"Why Timers Matter","text":"<p>Timers are one of the most essential peripherals for real-world embedded systems. They allow your program to:</p> <ul> <li>Delay an operation for a fixed time</li> <li>Toggle LEDs at precise intervals (blinking)</li> <li>Measure durations between events (e.g., how long a button is pressed)</li> <li>Generate PWM (Pulse Width Modulation)</li> <li>Act as the heartbeat of an RTOS (Real-Time Operating System)</li> </ul>"},{"location":"chapters/chapter-5/#software-loops-vs-hardware-timers","title":"Software Loops vs Hardware Timers","text":"Method Accurate? Affects CPU? Good for... Software Delay \u274c \u2705 Yes Quick hacks, rough timing Hardware Timer \u2705 \u274c No Precise, real-time timing <p>Timers are especially powerful when combined with interrupts, allowing your code to respond to time events without constantly checking them.</p> <p>In the next section, we\u2019ll explore how to configure and use timers on the PIC24 \u2014 including key registers and modes.</p>"},{"location":"chapters/chapter-5/#section-2-timer-configuration-on-the-pic24","title":"Section 2: Timer Configuration on the PIC24","text":"<p>The PIC24 family includes multiple timers (Timer1, Timer2, etc.) that can be configured using special function registers (SFRs). To make a timer do anything useful, you\u2019ll need to configure:</p> <ul> <li>The timer control register (e.g., <code>T1CON</code>)</li> <li>The period register (<code>PRx</code>) \u2014 when the timer should reset</li> <li>The timer count register (<code>TMRx</code>) \u2014 current value</li> <li>Optional: prescaler, interrupt enable, and clock source</li> </ul>"},{"location":"chapters/chapter-5/#basic-timer-setup-steps","title":"\ud83d\udd39 Basic Timer Setup Steps","text":"<p>Here\u2019s a typical configuration for a simple periodic timer:</p> <pre><code>T1CON = 0                // Common practice to set everything low before modifying the bits you do care about\nT1CONbits.TCKPS = 0b10;     // Prescaler = 1:64\nPR1 = 15625;             // Set period register (timer resets at this value)\nTMR1 = 0;                // Clear the timer count\nT1CONbits.TON = 1;       // Turn on Timer1\n</code></pre>"},{"location":"chapters/chapter-5/#key-timer-registers-for-timerx","title":"Key Timer Registers (for TimerX)","text":"Register Description <code>T\u27e8x\u27e9CON</code> Timer Control Register for TimerX <code>PR\u27e8x\u27e9</code> Period Register \u2014 timer resets at this value <code>TMR\u27e8x\u27e9</code> Timer Count Register (increments over time) <code>IFS0bits.T\u27e8x\u27e9IF</code> Interrupt Flag \u2014 set when timer expires <code>IEC0bits.T\u27e8x\u27e9IE</code> Interrupt Enable bit <p>Replace \u27e8x\u27e9 with the timer number: 1, 2, 3, etc.</p>"},{"location":"chapters/chapter-5/#prescaler-controlling-timer-speed","title":"Prescaler: Controlling Timer Speed","text":"<p>Most timers have a prescaler, which divides the system clock slow down how fast the timer increments.  For example:</p> Prescaler Description 1:1 Fastest (no division) 1:8 8\u00d7 slower 1:64 64\u00d7 slower 1:256 Slowest \u2014 256\u00d7 slower <p>Choose a prescaler so your period fits nicely within a 16-bit register (0\u201365535).</p> <p>Tip: If your timer counts too fast, try increasing the prescaler or switching to a 32-bit timer by combining two 16-bit timers (e.g., Timer2 + Timer3).</p> <p>In the next section, we\u2019ll explore interrupts \u2014 and how they make timers even more powerful by allowing your code to respond asynchronously when the timer expires.</p>"},{"location":"chapters/chapter-5/#section-3-interrupts-responding-to-events","title":"Section 3: Interrupts - Responding to Events","text":"<p>In a real-world embedded system, you often want your code to respond as soon as something happens \u2014 without constantly checking for it. That\u2019s where interrupts come in.</p> <p>An interrupt is a hardware-triggered event that causes the processor to pause what it\u2019s doing and run a special function called an Interrupt Service Routine (ISR).</p>"},{"location":"chapters/chapter-5/#why-use-interrupts","title":"\ud83d\udd39 Why Use Interrupts?","text":"<p>Without interrupts, you'd need to use polling \u2014 continuously checking for a condition inside a loop:</p> <pre><code>while (!timerExpired) {\n    // check again and again...\n}\n</code></pre> <p>This wastes CPU cycles. Instead, interrupts allow the microcontroller to do other things and only respond when needed. </p>"},{"location":"chapters/chapter-5/#how-interrupts-work-in-pic24","title":"How Interrupts Work in PIC24","text":"<p>When an interrupt occurs (e.g., a timer hits <code>PRx</code>):</p> <ol> <li>The CPU pauses the main program</li> <li>The return address and some key registers are pushed onto the stack</li> <li>The ISR is executed (defined by you)</li> <li>A <code>RETFIE</code> (Return from Interrupt) instruction:</li> <li>Pops saved values from the stack</li> <li>Resumes main code exactly where it left off</li> </ol>"},{"location":"chapters/chapter-5/#example-timer1-interrupt-flow","title":"Example: Timer1 Interrupt Flow","text":"<p>Assuming you've enabled the Timer1 interrupt:</p> <pre><code>void __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    IFS0bits.T1IF = 0;  // Clear interrupt flag\n    // Handle event (e.g., toggle LED)\n}\n</code></pre> <p>This function runs automatically every time Timer1. <code>IFS0bits.T1IF</code> must be cleared manually at the beginning of the ISR to prevent retriggering </p>"},{"location":"chapters/chapter-5/#interrupt-stack-behavior","title":"Interrupt Stack Behavior","text":"Action What Happens Interrupt occurs Return address + status pushed to stack ISR runs Executes your code RETFIE Pops return data and resumes main program <p>This is very similar to a <code>CALL</code>, but initiated by the hardware rather than code. </p>"},{"location":"chapters/chapter-5/#section-4-blinking-an-led-with-a-timer-interrupt","title":"Section 4: Blinking an LED with a Timer Interrupt","text":"<p>Let\u2019s build one of the most classic embedded applications: blinking an LED at regular intervals using a hardware timer and interrupt.</p>"},{"location":"chapters/chapter-5/#goal","title":"\ud83d\udd39 Goal","text":"<ul> <li>Use Timer1 to generate an interrupt every 500 ms</li> <li>Each time the interrupt occurs, toggle an LED connected to PORTB, bit 0</li> </ul>"},{"location":"chapters/chapter-5/#configuration-timer-interrupt-gpio","title":"Configuration: Timer + Interrupt + GPIO","text":"<p>Here\u2019s a complete example:</p> <pre><code>// Setup in main()\nTRISBbits.TRISB0 = 0;         // Set RB0 as output\nLATBbits.LATB0 = 0;           // Initialize LED OFF\n\nT1CONbits.TCKPS = 3;          // Prescaler 1:256\nPR1 = 31250;                  // 500ms interval with Fcy = 16MHz\nTMR1 = 0;\n\nIFS0bits.T1IF = 0;            // Clear interrupt flag\nIEC0bits.T1IE = 1;            // Enable Timer1 interrupt\nT1CONbits.TON = 1;            // Turn on Timer1\n\n// Interrupt Service Routine\nvoid __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    LATBbits.LATB0 ^= 1;      // Toggle LED\n    IFS0bits.T1IF = 0;        // Clear interrupt flag\n}\n</code></pre>"},{"location":"chapters/chapter-5/#why-this-works","title":"Why This Works","text":"<ul> <li>The timer counts up to <code>PR1</code> and triggers an interrupt  </li> <li>The ISR toggles the LED and resets the flag  </li> <li>The processor automatically returns to your main loop without losing track</li> </ul> <p>You don\u2019t need to manually check the timer \u2014 the interrupt does the work!</p>"},{"location":"chapters/chapter-5/#microsim-timer-and-isr-visualization","title":"\ud83e\uddea MicroSim: Timer and ISR Visualization","text":"<p>To see a timer and interrupt interaction in action, try this interactive simulation:</p> <p>\ud83d\udc49 Launch the Timer ISR Simulation</p> <p>Features:</p> <ul> <li>Set a PR1 value (interrupt match threshold)</li> <li>Watch the timer increment in real time</li> <li>When TMR1 reaches PR1:</li> <li>An interrupt is triggered</li> <li>The indicator cycles through red \u2192 yellow \u2192 green with each match</li> <li>Press Start, Stop, or Reset to control the behavior</li> </ul> <p>This simulation helps you visualize periodic interrupts and how the system responds each time an interrupt occurs.</p>"},{"location":"chapters/chapter-5/#timing-notes","title":"Timing Notes","text":"<p>This example assumes: - Fcy = 16 MHz (i.e., 8 MHz instruction cycle) - Prescaler = 1:256 - PR1 = 31250 \u2192 500 ms</p> <p>If your clock speed is different, you'll need to recalculate <code>PR1</code>.</p>"},{"location":"chapters/chapter-5/#section-5-summary-and-best-practices","title":"Section 5: Summary and Best Practices","text":"<p>Timers and interrupts are two of the most powerful features of any microcontroller \u2014 and they often work best together.</p>"},{"location":"chapters/chapter-5/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>A timer is a hardware counter that increments with time</li> <li>Use <code>PRx</code> to define the period, and <code>TMRx</code> to track the current count</li> <li>Prescalers help slow the timer down to match your time intervals</li> <li>When a timer reaches its period, it can trigger an interrupt</li> <li>The interrupt service routine (ISR) runs automatically, handles the task, and returns</li> <li>Interrupts use the stack to preserve your program state</li> </ul>"},{"location":"chapters/chapter-5/#best-practices","title":"Best Practices","text":"<ul> <li>\u2714\ufe0f Always clear the interrupt flag (<code>IFSx</code>) inside your ISR</li> <li>\u2714\ufe0f Keep ISRs short and efficient \u2014 don\u2019t do too much inside</li> <li>\u2714\ufe0f Use prescalers to avoid overflow and fit time into a 16-bit period</li> <li>\u2714\ufe0f For more timing flexibility, consider 32-bit timers (pairing TMR2 + TMR3)</li> <li>\u274c Avoid polling timers unless your task is very short or must be ultra-deterministic</li> <li>\u274c Never use <code>delay()</code> loops when timers can do the job more cleanly</li> </ul> <p>Next, we\u2019ll take what we\u2019ve learned about interrupts and apply it to external inputs \u2014 so your microcontroller can respond to real-world events like button presses or signal edges in Chapter 6: External Interrupts &amp; Input Capture.</p>"},{"location":"chapters/chapter-5/#quiz-timers-and-interrupts","title":"Quiz: Timers and Interrupts","text":"<p>What happens when the timer reaches the value in <code>PR1</code> and interrupts are enabled?</p> <pre><code>T1CONbits.TON = 1;\nPR1 = 31250;\nIEC0bits.T1IE = 1;\n</code></pre> <ol> <li>The timer stops and resets to 0  </li> <li>The CPU halts until the flag is cleared  </li> <li>An interrupt is triggered and the ISR runs  </li> <li>The timer overflows and restarts silently  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>Once the timer reaches <code>PR1</code>, it resets to 0 and triggers an interrupt \u2014 only if interrupts are enabled. This causes the processor to run the ISR (Interrupt Service Routine) associated with that timer. After the ISR completes and the flag is cleared, the main program resumes.</p>"},{"location":"chapters/chapter-5/#prompt-practice","title":"Prompt Practice","text":"<p>Write code that configures Timer1 to generate an interrupt every 250 milliseconds, assuming a system clock (Fcy) of 16 MHz. In the ISR, toggle an LED connected to PORTB bit 2.</p> Click to show solution <pre><code>// Main setup\nTRISBbits.TRISB2 = 0;           // RB2 as output\nLATBbits.LATB2 = 0;             // Start with LED OFF\n\nT1CONbits.TCKPS = 3;            // Prescaler 1:256\nPR1 = 15625;                    // 250ms at Fcy = 16MHz\nTMR1 = 0;\n\nIFS0bits.T1IF = 0;              // Clear interrupt flag\nIEC0bits.T1IE = 1;              // Enable Timer1 interrupt\nT1CONbits.TON = 1;              // Turn on Timer1\n\n// ISR\nvoid __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {\n    LATBbits.LATB2 ^= 1;        // Toggle LED\n    IFS0bits.T1IF = 0;          // Clear interrupt flag\n}\n</code></pre>"},{"location":"chapters/chapter-6/","title":"Chapter 6: External Interrupts &amp; Input Capture","text":""},{"location":"chapters/chapter-6/#section-1-what-are-external-interrupts","title":"Section 1: What Are External Interrupts?","text":"<p>External interrupts allow your microcontroller to react immediately to changes on specific input pins, such as when a button is pressed, a sensor detects motion, or a digital signal changes state.</p>"},{"location":"chapters/chapter-6/#how-they-work","title":"How They Work","text":"<p>External interrupts are triggered by electrical transitions on dedicated interrupt pins:</p> <ul> <li>Rising edge \u2192 when the signal goes from LOW (0) to HIGH (1)</li> <li>Falling edge \u2192 when the signal goes from HIGH (1) to LOW (0)</li> <li>Some systems allow both edges to trigger an interrupt</li> </ul> <p>When such a change is detected, the microcontroller pauses its current task, runs a specific function called an Interrupt Service Routine (ISR), then returns to what it was doing \u2014 all within a few cycles.</p>"},{"location":"chapters/chapter-6/#hardware-lines-intx","title":"Hardware Lines: INTx","text":"<p>The PIC24 provides dedicated external interrupt inputs: - <code>INT0</code> is fixed to a specific pin and always uses rising edge detection - <code>INT1</code>, <code>INT2</code>, etc. are configurable: you can choose rising or falling edge - Each has its own flag (<code>IFSx</code>), enable bit (<code>IECx</code>), and priority level (<code>IPCx</code>)</p>"},{"location":"chapters/chapter-6/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Detecting a button press (toggle an LED, start/stop a timer)</li> <li>Triggering logic when an object breaks a beam sensor</li> <li>Starting an event when a signal changes state</li> <li>Reading a pulse train from another digital system</li> </ul> <p>External interrupts allow your microcontroller to be responsive without constant polling \u2014 saving power and processing time.</p> <p>In the next section, we\u2019ll show how to configure these interrupts on the PIC24 and respond to real-world input like a button press.</p>"},{"location":"chapters/chapter-6/#section-2-configuring-external-interrupts-intx","title":"Section 2: Configuring External Interrupts (INTx)","text":"<p>To use an external interrupt on the PIC24, you'll need to configure three main things:</p> <ol> <li>Edge sensitivity \u2014 rising or falling</li> <li>Enable the interrupt</li> <li>Clear the interrupt flag in your ISR</li> </ol>"},{"location":"chapters/chapter-6/#basic-setup-int1","title":"\ud83d\udd39 Basic Setup: INT1","text":"<p>Here\u2019s how to configure INT1 to trigger on a falling edge (e.g. button press):</p> <pre><code>TRISBbits.TRISB7 = 1;              // Set RB7 as input\nINTCON2bits.INT1EP = 1;            // 1 = falling edge, 0 = rising edge\n\nIFS1bits.INT1IF = 0;               // Clear interrupt flag\nIEC1bits.INT1IE = 1;               // Enable INT1 interrupt\n</code></pre> <p>And the corresponding ISR:</p> <pre><code>void __attribute__((__interrupt__, auto_psv)) _INT1Interrupt(void) {\n    IFS1bits.INT1IF = 0;           // Clear the interrupt flag\n    LATBbits.LATB0 = 1;           // Toggle LED (for example)\n}\n</code></pre>"},{"location":"chapters/chapter-6/#register-summary-for-int1","title":"Register Summary for INT1","text":"Register Purpose <code>INTCON2bits.INT1EP</code> 1 = falling edge, 0 = rising edge <code>IEC1bits.INT1IE</code> Enable bit for INT1 <code>IFS1bits.INT1IF</code> Interrupt flag for INT1 <code>IPC5bits.INT1IP</code> Priority level (optional)"},{"location":"chapters/chapter-6/#example-toggle-led-on-button-press","title":"Example: Toggle LED on Button Press","text":"<p>You can connect a button between <code>RB7</code> and GND. When pressed, the line goes LOW, triggering the falling edge interrupt. The ISR toggles an LED on <code>RB0</code>.</p> <p>Remember to include a pull-up resistor (internal or external) to hold <code>RB7</code> HIGH when the button is not pressed.</p>"},{"location":"chapters/chapter-6/#quick-note-pull-up-resistors","title":"Quick Note: Pull-Up Resistors","text":"<p>When using an external interrupt triggered by a button, the pin needs to have a known voltage level when the button is not pressed. Otherwise, it may float unpredictably and trigger false interrupts.</p> <p>A pull-up resistor holds the line HIGH by default. When the button is pressed, it pulls the line LOW \u2014 creating a clean falling edge.</p> <p>You can use: - An external pull-up resistor (e.g., 10k\u03a9 to Vdd), or - Enable the internal pull-up (on some PIC24 devices via <code>CNPUx</code> register)</p> <p>This ensures your interrupt only fires when the button is intentionally pressed.</p> <p>Next, we\u2019ll explore Input Capture, a different kind of input interrupt used for measuring timing of digital signals.</p>"},{"location":"chapters/chapter-6/#section-3-what-is-input-capture","title":"Section 3: What Is Input Capture?","text":"<p>While external interrupts help detect when an event occurs, input capture helps you measure how long something took or when exactly it happened \u2014 with precision.</p> <p>Input capture is used to record the exact timer value at the moment an external signal changes. This allows you to measure things like:</p> <ul> <li>The time between two button presses</li> <li>The frequency of a square wave</li> <li>The pulse width of a PWM signal</li> </ul>"},{"location":"chapters/chapter-6/#why-use-input-capture","title":"Why Use Input Capture?","text":"<p>Input capture modules are tightly linked to timers. They \"capture\" the current timer count and store it in a buffer the moment a specified edge occurs.</p> <p>This enables precise time stamping without needing to poll the input manually.</p>"},{"location":"chapters/chapter-6/#key-use-cases","title":"Key Use Cases","text":"<ul> <li>Pulse width measurement (how long a signal stayed high or low)</li> <li>Frequency detection (time between rising edges)</li> <li>Reaction timing (time between stimulus and response)</li> <li>Detecting variable pulse signals like servo control or ultrasonic sensors</li> </ul>"},{"location":"chapters/chapter-6/#input-capture-vs-external-interrupts","title":"Input Capture vs External Interrupts","text":"Feature External Interrupt Input Capture Purpose Trigger code Record time of event Edge Response ISR runs on edge Timer value recorded Useful For Logic control Precision timing CPU Involvement Immediate ISR Minimal \u2014 buffered <p>Use input capture when you're more interested in when something happened than what should happen immediately.</p> <p>In the next section, we\u2019ll walk through how to configure and use input capture modules on the PIC24.</p>"},{"location":"chapters/chapter-6/#section-4-setting-up-input-capture-icx","title":"Section 4: Setting Up Input Capture (ICx)","text":"<p>To use Input Capture on the PIC24, you'll configure one of the ICx modules (e.g., IC1, IC2) to record the timer value when a digital signal changes on a designated pin.</p> <p>The capture value is automatically placed into a buffer, which you can read later in software or inside an ISR.</p>"},{"location":"chapters/chapter-6/#basic-configuration-steps","title":"\ud83d\udd39 Basic Configuration Steps","text":"<ol> <li>Configure the pin as an input</li> <li>Select the timer source (usually TMR2 or TMR3)</li> <li>Set the edge mode (rising, falling, or every edge)</li> <li>Enable interrupts (optional, but common)</li> <li>Read the captured value from the ICx buffer</li> </ol>"},{"location":"chapters/chapter-6/#code-example-measure-time-between-pulses","title":"Code Example: Measure Time Between Pulses","text":"<pre><code>// Setup for IC1 using Timer2\nIC1CON = 0\nT2CON = 0                         //Set the configuration to 0 as good practice\nTRISBbits.TRISB2 = 1;             // Set RB2 (IC1 input) as input\n\nT2CONbits.TCKPS = 2;              // Prescaler 1:64\nTMR2 = 0;\nPR2 = 0xFFFF;\nT2CONbits.TON = 1;                // Turn on Timer2\n\nIC1CONbits.ICM = 1;               // Capture on every rising edge\nIC1CONbits.ICTMR = 1;            // Use Timer2 as time base\nIC1CONbits.ICI = 0;              // Interrupt on every capture\nIC1CONbits.ON = 1;               // Enable Input Capture\n\nIFS0bits.IC1IF = 0;              // Clear interrupt flag\nIEC0bits.IC1IE = 1;              // Enable interrupt\n\n// ISR to read captured time\nvoid __attribute__((__interrupt__, auto_psv)) _IC1Interrupt(void) {\n    IFS0bits.IC1IF = 0;          // Clear interrupt flag\n    uint16_t time = IC1BUF;      // Read captured timer value\n}\n</code></pre>"},{"location":"chapters/chapter-6/#edge-detection-options","title":"Edge Detection Options","text":"Mode Value Trigger Condition 1 Every rising edge 2 Every falling edge 3 Every edge (rising + falling) 0 Module disabled <p>Set using: <code>ICxCONbits.ICM = value;</code></p> <p>You can change the capture mode on the fly if you want to capture both rising and falling edges in sequence.</p>"},{"location":"chapters/chapter-6/#interactive-input-capture-simulation","title":"\ud83c\udfaf Interactive Input Capture Simulation","text":"<p>To deepen your understanding of how Input Capture modules operate, interact with the simulation below. Experiment with different pulse durations and observe how timer values are recorded at the rising edge of a signal.</p> <ul> <li>Press Start Pulse to simulate a rising edge event.</li> <li>Adjust the Pulse Duration using the slider before starting the pulse.</li> <li>Watch how the captured timer value changes based on pulse width!</li> </ul> <p>\ud83d\udc49 Launch the Input Capture Simulation</p> <p>In the next section, we\u2019ll summarize the difference between external interrupts and input capture, and wrap up with tips and use cases.</p>"},{"location":"chapters/chapter-6/#section-5-summary-and-best-practices","title":"Section 5: Summary and Best Practices","text":"<p>External interrupts and input capture give your microcontroller the ability to react to real-world events and measure their timing precisely \u2014 both essential tools in embedded systems.</p>"},{"location":"chapters/chapter-6/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>External Interrupts (INTx):</li> <li>Trigger an ISR when a pin changes (rising/falling edge)</li> <li>Great for reacting to button presses or logic events</li> <li> <p>Must clear the interrupt flag inside the ISR</p> </li> <li> <p>Input Capture (ICx):</p> </li> <li>Records the timer value when a pin changes</li> <li>Perfect for measuring pulse width, frequency, or time between events</li> <li> <p>Doesn\u2019t require logic inside the ISR (just read <code>ICxBUF</code>)</p> </li> <li> <p>Both can be configured for rising, falling, or both edges</p> </li> </ul>"},{"location":"chapters/chapter-6/#best-practices","title":"Best Practices","text":"<ul> <li>\u2714\ufe0f Use pull-up or pull-down resistors to ensure clean digital signals</li> <li>\u2714\ufe0f Debounce buttons (in software or hardware) to avoid multiple triggers</li> <li>\u2714\ufe0f Clear flags inside the ISR: <code>IFSxbits.INTxIF</code> or <code>ICxIF</code></li> <li>\u2714\ufe0f Use input capture when timing is more important than triggering behavior</li> <li>\u274c Don\u2019t read <code>ICxBUF</code> unless <code>ICxIF</code> is set \u2014 you could get junk data</li> </ul>"},{"location":"chapters/chapter-6/#-","title":"---","text":""},{"location":"chapters/chapter-6/#note-peripheral-pin-mapping-pps","title":"Note: Peripheral Pin Mapping (PPS)","text":"<p>On PIC24 devices with remappable pins, you must use Peripheral Pin Select (PPS) to assign Input Capture (ICx), Output Compare (OCx), UART, and other modules to specific physical pins.</p> <p>For example, to map IC1 to RP7 (e.g., RB7):</p> <pre><code>__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPINR7bits.IC1R = 7;                      // IC1 input = RP7\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n</code></pre> <p>Skipping this step may cause ICx or OCx modules to appear non-functional.</p> <p>Always refer to your microcontroller\u2019s datasheet or family reference manual to find valid RPx mappings for your device.</p> <p>Next, we\u2019ll explore how to generate waveforms and control power using output compare and PWM in Chapter 7!</p>"},{"location":"chapters/chapter-6/#quiz-external-interrupts-input-capture","title":"Quiz: External Interrupts &amp; Input Capture","text":"<p>What does the input capture module do when it detects a rising edge on its input pin?</p> <pre><code>IC1CONbits.ICM = 1;   // Capture on rising edge\n</code></pre> <ol> <li>Immediately jumps to an interrupt  </li> <li>Saves the value of PRx  </li> <li>Saves the value of TMRx into IC1BUF  </li> <li>Resets the timer to zero  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>The input capture module stores the current value of the timer (usually TMR2 or TMR3) into <code>IC1BUF</code> when the rising edge occurs. This lets you determine exactly when the signal changed \u2014 great for measuring duration, frequency, or spacing between pulses.</p>"},{"location":"chapters/chapter-6/#prompt-practice","title":"Prompt Practice","text":"<p>Write code that configures Input Capture 1 (IC1) to capture the time of every falling edge on pin RP7, using Timer2 as the time base. Assume you\u2019ve already configured <code>TMR2</code> with an appropriate prescaler.</p> Click to show solution <pre><code>// Set up pin mapping: IC1 on RP7 (RB7)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPINR7bits.IC1R = 7;                      // Map IC1 input to RP7\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure IC1\nTRISBbits.TRISB7 = 1;           // RB7 as input\nIC1CONbits.ICTMR = 1;           // Use Timer2 as time base\nIC1CONbits.ICM = 2;             // Capture on falling edge\nIC1CONbits.ICI = 0;             // Interrupt on every event\nIC1CONbits.ON = 1;              // Turn on IC1\n\nIFS0bits.IC1IF = 0;             // Clear interrupt flag\nIEC0bits.IC1IE = 1;             // Enable interrupt\n\n// IC1 ISR\nvoid __attribute__((__interrupt__, auto_psv)) _IC1Interrupt(void) {\n    uint16_t timeStamp = IC1BUF;   // Read captured time\n    IFS0bits.IC1IF = 0;            // Clear flag\n}\n</code></pre>"},{"location":"chapters/chapter-7/","title":"Chapter 7: Output Compare &amp; PWM","text":""},{"location":"chapters/chapter-7/#section-1-what-is-output-compare","title":"Section 1: What Is Output Compare?","text":"<p>The Output Compare (OCx) module on the PIC24 allows you to generate a digital output signal based on a timer match event.</p> <p>At a high level, you configure a timer (like <code>TMR2</code>), and when the timer reaches a specific value stored in the <code>OCxR</code> or <code>OCxRS</code> register, the output pin toggles, sets, clears, or pulses depending on your chosen mode.</p>"},{"location":"chapters/chapter-7/#what-its-used-for","title":"What It's Used For","text":"<ul> <li>Generate precise timing pulses</li> <li>Toggle an output pin without software involvement</li> <li>Create PWM signals by controlling pulse width via timer values</li> </ul>"},{"location":"chapters/chapter-7/#how-it-works","title":"How It Works","text":"<ol> <li>Timer (e.g., <code>TMR2</code>) counts up</li> <li>When <code>TMR2</code> matches <code>OCxR</code>, the output pin changes</li> <li>In PWM mode, this continues as long as the timer runs</li> </ol> <p>This all happens in hardware, without using up CPU cycles.</p>"},{"location":"chapters/chapter-7/#core-registers-example-oc1","title":"Core Registers (Example: OC1)","text":"Register Role <code>OC1R</code> Compare value \u2014 when output changes initially <code>OC1RS</code> Secondary compare \u2014 used in PWM mode <code>OC1CON</code> Control register for mode selection and timer link <code>OC1IF</code> Interrupt flag (optional use) <p>Output Compare modules are tightly tied to timers \u2014 most often TMR2 or TMR3 \u2014 because these timers are 16-bit, high-resolution, and designed for timing tasks like PWM generation. Timers like TMR1 are typically reserved for timekeeping or general interrupts, while TMR2/TMR3 are better suited for waveform generation.</p> <p>In the next section, we\u2019ll step back briefly and explain what Pulse Width Modulation (PWM) is \u2014 since that\u2019s the most popular use case for Output Compare modules.</p>"},{"location":"chapters/chapter-7/#section-2-what-is-pwm-pulse-width-modulation","title":"Section 2: What Is PWM (Pulse Width Modulation)?","text":"<p>Pulse Width Modulation (PWM) is a technique used to simulate analog control using a digital signal that rapidly switches between HIGH and LOW.</p> <p>Instead of sending a constant voltage, PWM sends pulses \u2014 and by controlling how long the signal stays HIGH during each cycle, you can control the average power delivered.</p>"},{"location":"chapters/chapter-7/#key-concepts","title":"Key Concepts","text":"<ul> <li>Period: The total duration of one complete on/off cycle</li> <li>Duty cycle: The percentage of the period that the signal is HIGH</li> <li>100% duty = always ON</li> <li>0% duty = always OFF</li> <li>50% duty = ON for half the time, OFF for the other half</li> <li>Frequency: How many PWM cycles occur per second (Hz)</li> </ul>"},{"location":"chapters/chapter-7/#why-its-useful","title":"Why It's Useful","text":"<p>PWM allows you to:</p> <ul> <li>Dim an LED by adjusting brightness</li> <li>Control motor speed or servo position</li> <li>Modulate audio signals</li> <li>Generate analog-like control signals without needing a dedicated Digital-to-Analog Converter (DAC) \u2014 the PWM duty cycle controls the average voltage instead.</li> </ul> <p>All of this is done with just one digital output pin.</p>"},{"location":"chapters/chapter-7/#example-duty-cycles","title":"Example Duty Cycles","text":"Duty Cycle Description 0% Always OFF 25% Brief ON, mostly OFF 50% Equal ON and OFF 75% Mostly ON 100% Always ON <p>Adjusting duty cycle lets you control how much \"power\" a device receives over time.</p>"},{"location":"chapters/chapter-7/#pwm-visualization","title":"PWM Visualization","text":"<p>To better visualize how Pulse Width Modulation (PWM) controls signal timing and brightness, use the interactive simulation below:</p> <p>\ud83d\udc49 Launch the PWM Visualization Simulation</p> <p>Adjust the duty cycle and see how waveform shape and LED intensity respond in real time!</p> <p>Use the slider to adjust the duty cycle and see: - How the waveform changes - How an LED's brightness is influenced by PWM on-time</p> <p>In the next section, we\u2019ll connect this concept to Output Compare and show how to generate PWM signals in hardware using the <code>OCx</code> module.</p>"},{"location":"chapters/chapter-7/#section-3-generating-pwm-with-output-compare","title":"Section 3: Generating PWM with Output Compare","text":"<p>Now that you understand how PWM works, let's generate it in hardware using the Output Compare (OCx) module on the PIC24.</p> <p>The OCx module can be configured to output a PWM signal using a timer (typically <code>TMR2</code> or <code>TMR3</code>) as a time base.</p>"},{"location":"chapters/chapter-7/#configuration-overview","title":"Configuration Overview","text":"<p>To generate PWM with <code>OCx</code>:</p> <ol> <li>Set up a timer (<code>TMR2</code> or <code>TMR3</code>) with the desired period</li> <li>Set <code>OCxR</code> to define when the pulse goes HIGH</li> <li>Set <code>OCxRS</code> to define when the pulse goes LOW</li> <li>Configure <code>OCxCON</code> to enable PWM mode</li> <li>Map the OCx output to a physical pin (using PPS if required)</li> </ol>"},{"location":"chapters/chapter-7/#example-50-duty-cycle-on-oc1-using-tmr2","title":"Example: 50% Duty Cycle on OC1 using TMR2","text":"<pre><code>//Setting configuration so we don't keep any unwanted specification from prior, good practice\nT2CON = 0\nOC1CON = 0                 \n\n// Map OC1 output to RP9 (e.g., RB9)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 18;                      // RP9 = OC1\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure OC1 for PWM\nOC1CONbits.OCM = 0b110;           // PWM mode, fault pin disabled\nOC1CONbits.OCTSEL = 0;            // Use Timer2\nOC1RS = 25000;                    // 50% duty cycle (pulse ends here)\nOC1R = 25000;                     // Initial pulse start point\nOC1CONbits.ON = 1;                // Enable Output Compare\n\n// Configure Timer2 for PWM period\nT2CONbits.TCKPS = 0b010;          // Prescaler 1:64\nPR2 = 49999;                      // Sets PWM period\nTMR2 = 0;\nT2CONbits.TON = 1;                // Start Timer2\n</code></pre>"},{"location":"chapters/chapter-7/#notes-on-values","title":"Notes on Values","text":"<ul> <li><code>PR2</code> sets the period of the PWM</li> <li><code>OC1RS</code> sets the duty cycle (pulse width)</li> <li>A value of <code>OC1RS = PR2 / 2</code> gives 50% duty</li> <li>You can change <code>OC1RS</code> on the fly to adjust brightness/speed/etc.</li> </ul> <p>Think of the timer as the metronome and OCx as the switch that turns the output pin ON and OFF with precise timing.</p> <p>Next, we\u2019ll compare this hardware PWM with the software-based version \u2014 and show why hardware is often the better choice.</p>"},{"location":"chapters/chapter-7/#section-4-software-vs-hardware-pwm","title":"Section 4: Software vs Hardware PWM","text":"<p>There are two ways to generate a PWM signal on a microcontroller:</p> <ol> <li>Software PWM \u2014 manually toggle a pin inside a loop</li> <li>Hardware PWM \u2014 use the Output Compare (OCx) module linked to a timer</li> </ol> <p>Let\u2019s compare the two approaches:</p>"},{"location":"chapters/chapter-7/#software-pwm","title":"Software PWM","text":"<p>In software PWM, you write code like this:</p> <pre><code>while (1) {\n    LATBbits.LATB1 = 1;      // Set HIGH\n    delay_us(500);           // ON time\n    LATBbits.LATB1 = 0;      // Set LOW\n    delay_us(500);           // OFF time\n}\n</code></pre> <p>This works, but it: - Uses the CPU 100% of the time - Is affected by interrupts or timing jitter - Doesn\u2019t scale well (you can\u2019t drive many PWM channels at once)</p>"},{"location":"chapters/chapter-7/#hardware-pwm-with-output-compare","title":"Hardware PWM (with Output Compare)","text":"<p>In hardware PWM, once you configure the <code>OCx</code> module, the PWM output runs automatically in the background.</p> <p>Benefits: - Doesn't use CPU cycles - Precise timing tied to hardware clock - Reliable frequency and duty cycle - Scales well (multiple OCx channels)</p> <p>Hardware PWM is like a metronome: once set, it keeps time perfectly \u2014 while your code is free to focus on other tasks.</p> <p>Unless you need something very custom, hardware PWM is always the better choice when available.</p>"},{"location":"chapters/chapter-7/#comparison-table","title":"Comparison Table","text":"Feature Software PWM Hardware PWM (OCx) CPU Usage High (manual toggling) Minimal (runs independently) Timing Accuracy Affected by code &amp; delays Very accurate (timer-based) Interrupt Sensitivity High Low Scalability Poor (one pin at a time) Excellent (multiple OCx modules) Power Efficiency Low High <p>Use hardware PWM whenever precise, low-overhead control is needed.</p> <p>Next, we\u2019ll wrap up with common applications and best practices.</p>"},{"location":"chapters/chapter-7/#section-5-summary-and-use-cases","title":"Section 5: Summary and Use Cases","text":"<p>The Output Compare (OCx) module is one of the most powerful peripherals on the PIC24 \u2014 especially when used to generate PWM signals.</p> <p>Paired with a timer, it allows you to produce high-precision digital waveforms that simulate analog control \u2014 without using CPU time.</p>"},{"location":"chapters/chapter-7/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Output Compare compares a timer value to a register (<code>OCxR</code>/<code>OCxRS</code>) and toggles an output accordingly.</li> <li>PWM (Pulse Width Modulation) controls average power by varying ON/OFF times.</li> <li>Hardware PWM is far superior to software-based PWM in timing accuracy, scalability, and CPU usage.</li> <li>You can remap OCx to various output pins using Peripheral Pin Select (PPS).</li> </ul>"},{"location":"chapters/chapter-7/#real-world-applications","title":"Real-World Applications","text":"Application How PWM Helps LED Dimming Adjust brightness by changing duty cycle Servo Control Send precise pulse widths (1\u20132 ms range) Motor Speed Control Modulate voltage applied to motor coils Audio Generation Output tones or waveforms digitally Power Regulation Smooth delivery of variable DC voltage <p>PWM is everywhere \u2014 from drone motors to smart lightbulbs.</p> <p>Next up, we\u2019ll explore communication and peripheral modules, including UART, SPI, I2C, and ADCs!</p>"},{"location":"chapters/chapter-7/#quiz-understanding-pwm-behavior","title":"Quiz: Understanding PWM Behavior","text":"<p>What happens if the value in <code>OC1RS</code> is set equal to <code>PR2</code> when generating PWM using Timer2?</p> <pre><code>PR2 = 40000;\nOC1RS = 40000;\n</code></pre> <ol> <li>The PWM signal will always be HIGH  </li> <li>The PWM signal will be 50% duty cycle  </li> <li>The PWM signal will always be LOW  </li> <li>The PWM signal will toggle randomly  </li> </ol> Show Answer <p>The correct answer is A.</p> <p>If <code>OC1RS</code> equals <code>PR2</code>, the pulse stays HIGH for the full duration of the PWM period \u2014 resulting in 100% duty cycle. The output never drops LOW during the cycle.</p>"},{"location":"chapters/chapter-7/#prompt-practice","title":"Prompt Practice","text":"<p>Write code to configure OC1 to generate a 75% duty cycle PWM signal on pin RP9, using Timer2 and a period of 20 ms (standard servo PWM timing). Assume a system clock of 16 MHz.</p> Click to show solution <pre><code>// Configure Timer2 for 20 ms period\nT2CONbits.TCKPS = 3;              // Prescaler 1:256\nPR2 = 1250;                       // 20 ms at 16 MHz / 256\n\nTMR2 = 0;\nT2CONbits.TON = 1;                // Start Timer2\n\n// Map OC1 output to RP9 (RB9)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 18;                      // RP9 = OC1\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// Configure OC1 for PWM mode\nOC1CONbits.OCM = 0b110;           // PWM mode, no fault pin\nOC1CONbits.OCTSEL = 0;            // Use Timer2\n\nOC1RS = 937;                      // 75% duty cycle (0.75 \u00d7 1250)\nOC1R = 937;                       // Initial compare value\nOC1CONbits.ON = 1;                // Enable Output Compare\n</code></pre>"},{"location":"chapters/chapter-8/","title":"Chapter 8: Communication &amp; Peripherals","text":""},{"location":"chapters/chapter-8/#section-1-why-communication-matters","title":"Section 1: Why Communication Matters","text":"<p>Microcontrollers are powerful, but they rarely operate in isolation. Most embedded systems need to communicate with other devices, whether it's a:</p> <ul> <li>Computer (e.g., serial terminal)</li> <li>Sensor (e.g., accelerometer, temperature probe)</li> <li>Display (e.g., OLED or LCD)</li> <li>Another microcontroller or peripheral</li> </ul> <p>To accomplish this, microcontrollers use a variety of serial communication protocols that allow them to send and receive data efficiently.</p>"},{"location":"chapters/chapter-8/#serial-vs-parallel-communication","title":"Serial vs Parallel Communication","text":"Type Description Example Use Parallel Multiple bits sent simultaneously (wider) Older systems, LCDs Serial Bits sent one at a time over fewer wires UART, SPI, I2C <p>Parallel is faster in theory, but requires many I/O pins and wires. Serial is simpler, more scalable, and dominates in modern designs.</p>"},{"location":"chapters/chapter-8/#why-we-use-uart-spi-and-i2c","title":"Why We Use UART, SPI, and I2C","text":"<p>These three protocols are the most common in microcontroller systems:</p> Protocol Wires Use Case Speed UART 2 PC communication, debugging Moderate (115200+ bps) SPI 4 High-speed peripherals, sensors Fast (MHz+) I2C 2 Multi-device, low-speed communication Moderate (~100k\u2013400kHz) <p>Each has tradeoffs \u2014 some are better for speed, some for simplicity, and some for connecting many devices.</p>"},{"location":"chapters/chapter-8/#tradeoffs-limitations","title":"Tradeoffs &amp; Limitations","text":"Protocol Limitations UART Only supports one-to-one communication, requires matching baud rates SPI Needs more wires, no built-in addressing, typically one master only I2C Slower than SPI, more complex protocol, can suffer from bus contention <p>Choosing the right protocol depends on the number of devices, speed requirements, and system complexity.</p> <p>In the next sections, we'll explore each protocol in detail, how to configure it on the PIC24, and common use cases.</p>"},{"location":"chapters/chapter-8/#section-2-uart-universal-asynchronous-receivertransmitter","title":"Section 2: UART (Universal Asynchronous Receiver/Transmitter)","text":"<p>UART is a simple serial communication protocol that sends and receives data asynchronously \u2014 meaning it doesn\u2019t need a shared clock between devices.</p> <p>Instead, both devices agree on a baud rate (bits per second), like <code>9600</code>, <code>38400</code>, or <code>115200</code>, and communicate using two lines:</p> <ul> <li>TX (transmit)</li> <li>RX (receive)</li> </ul>"},{"location":"chapters/chapter-8/#uart-frame-format","title":"UART Frame Format","text":"<p>Each UART message is made up of: - 1 start bit - 8 data bits (usually) - Optional parity bit - 1 stop bit</p> <p>So sending 1 byte over UART actually sends at least 10 bits.</p> <p>Timing is critical \u2014 both devices must use the same baud rate to avoid garbled data.</p>"},{"location":"chapters/chapter-8/#configuring-uart-on-the-pic24","title":"Configuring UART on the PIC24","text":"<p>UART modules are named <code>U1MODE</code>, <code>U1STA</code>, etc. for UART1. You\u2019ll also need to map TX/RX pins using PPS.</p> <p>Example: Echo received characters using UART1 at 9600 baud.</p> <pre><code>// Configure pins (TX = RP10, RX = RP8)\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR5bits.RP10R = 3;                      // U1TX on RP10\nRPINR18bits.U1RXR = 8;                    // U1RX on RP8\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// UART1 Settings\nU1MODEbits.BRGH = 0;                      // Standard speed mode\nU1BRG = 103;                              // Baud = 9600 (for 16MHz clock)\nU1MODEbits.UARTEN = 1;                    // Enable UART\nU1STAbits.UTXEN = 1;                      // Enable TX\n\n// Echo loop\nwhile (1) {\n    if (U1STAbits.URXDA) {               // Data available?\n        char c = U1RXREG;                // Read char\n        while (!U1STAbits.TRMT);         // Wait if TX is busy\n        U1TXREG = c;                     // Echo back\n    }\n}\n</code></pre>"},{"location":"chapters/chapter-8/#typical-use-cases","title":"Typical Use Cases","text":"<ul> <li>Serial terminals (via USB-to-UART converters)</li> <li>Debugging (print variables over UART)</li> <li>Interfacing with GPS, Bluetooth, or WiFi modules</li> </ul> <p>UART is often your first line of communication and debugging when bringing up a new project.</p> <p>Up next: we\u2019ll cover SPI, a faster protocol with full-duplex communication.</p>"},{"location":"chapters/chapter-8/#quiz-uart-communication","title":"Quiz: UART Communication","text":"<p>Which of the following must be true for two devices to successfully communicate over UART?</p> <ol> <li>They must share the same clock signal  </li> <li>They must have the same pin mappings  </li> <li>They must use the same baud rate  </li> <li>They must use a master-slave architecture  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>UART is asynchronous \u2014 there is no shared clock. However, both devices must be configured to use the same baud rate, or else the timing will be mismatched and the data will be corrupted.</p>"},{"location":"chapters/chapter-8/#prompt-practice","title":"Prompt Practice","text":"<p>Write code to configure UART1 to transmit the string <code>\"Hello\"</code> continuously at 115200 baud, using TX on RP9.</p> Click to show solution <pre><code>// PPS Mapping for UART1 TX\n__builtin_write_OSCCONL(OSCCON &amp; 0xbf);   // Unlock PPS\nRPOR4bits.RP9R = 3;                       // U1TX on RP9\n__builtin_write_OSCCONL(OSCCON | 0x40);   // Lock PPS\n\n// UART1 Settings\nU1MODEbits.BRGH = 0;                      // Standard speed\nU1BRG = 8;                                // 115200 baud @ 16MHz\nU1MODEbits.UARTEN = 1;                    // Enable UART\nU1STAbits.UTXEN = 1;                      // Enable TX\n\n// Transmit \"Hello\" forever\nwhile (1) {\n    const char *msg = \"Hello\\r\\n\";\n    for (int i = 0; msg[i] != '\\0'; i++) {\n        while (!U1STAbits.TRMT);          // Wait if TX is busy\n        U1TXREG = msg[i];\n    }\n    __delay_ms(1000);                     // Delay 1s between messages\n}\n</code></pre>"},{"location":"chapters/chapter-8/#section-3-spi-serial-peripheral-interface","title":"Section 3: SPI (Serial Peripheral Interface)","text":"<p>SPI is a high-speed, full-duplex communication protocol designed for fast data exchange between a master and one or more slaves.</p> <p>Unlike UART, SPI uses a shared clock line, which enables tight synchronization between devices.</p>"},{"location":"chapters/chapter-8/#spi-signals","title":"SPI Signals","text":"Line Name Direction (Master \u2192 Slave) SCK Clock \u2b05 Master provides clock MOSI Data \u2b05 Master Out, Slave In MISO Data \u2b05 Master In, Slave Out SS Select \u2b05 Active LOW (one per slave) <p>SPI is faster than UART or I2C and supports streaming data in both directions at once.</p>"},{"location":"chapters/chapter-8/#how-spi-works","title":"How SPI Works","text":"<ul> <li>The master controls the clock (SCK)</li> <li>Data is shifted out bit by bit on MOSI/MISO</li> <li>The slave select (SS) line tells which device is active</li> <li>Most devices use 8-bit or 16-bit transfers</li> </ul>"},{"location":"chapters/chapter-8/#configuring-spi-on-pic24-as-master","title":"Configuring SPI on PIC24 (as Master)","text":"<pre><code>// Set up SPI1 in Master mode (8-bit, clock = Fosc/16)\nSPI1CON = 0;\nSPI1CON1bits.MSTEN = 1;        // Master mode\nSPI1CON1bits.MODE16 = 0;       // 8-bit mode\nSPI1CON1bits.CKE = 1;          // Clock edge\nSPI1CON1bits.SMP = 0;          // Input sampled in middle\nSPI1CON1bits.SPRE = 0b110;     // Secondary prescaler 2:1\nSPI1CON1bits.PPRE = 0b10;      // Primary prescaler 4:1\nSPI1STATbits.SPIEN = 1;        // Enable SPI\n\n// Transmit one byte (0xAA)\nSPI1BUF = 0xAA;\nwhile (!SPI1STATbits.SPIRBF);  // Wait until received\nuint8_t received = SPI1BUF;    // Read incoming byte\n</code></pre>"},{"location":"chapters/chapter-8/#use-cases","title":"Use Cases","text":"<ul> <li>SD cards, flash memory</li> <li>OLED displays</li> <li>High-speed sensors (accelerometers, gyros)</li> <li>DACs or other peripherals needing fast streaming</li> </ul> <p>SPI is great for speed and low-latency, but requires more pins and doesn\u2019t support automatic addressing like I2C.</p> <p>Next up: we\u2019ll cover I2C, ideal for connecting many devices with fewer wires.</p>"},{"location":"chapters/chapter-8/#quiz-spi-basics","title":"Quiz: SPI Basics","text":"<p>Which of the following is NOT true about the SPI protocol?</p> <ol> <li>It uses a clock signal shared by the master  </li> <li>It can transfer and receive data simultaneously  </li> <li>It requires only one wire for communication  </li> <li>It allows for fast data exchange with peripherals  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>SPI uses at least 4 wires: SCK, MOSI, MISO, and SS. While it's fast and full-duplex, it\u2019s not a single-wire protocol like some asynchronous options.</p>"},{"location":"chapters/chapter-8/#prompt-practice_1","title":"Prompt Practice","text":"<p>Write code to configure SPI1 on the PIC24 to operate in 8-bit master mode, then send the value <code>0x55</code> and store the received byte.</p> Click to show solution <pre><code>// SPI1 Master Mode Setup\nSPI1CON1bits.MSTEN = 1;        // Master mode\nSPI1CON1bits.MODE16 = 0;       // 8-bit mode\nSPI1CON1bits.CKE = 1;          // Data changes on active-to-idle clock edge\nSPI1CON1bits.SMP = 0;          // Input sampled in middle of data output\nSPI1CON1bits.SPRE = 0b110;     // Secondary prescaler 2:1\nSPI1CON1bits.PPRE = 0b10;      // Primary prescaler 4:1\nSPI1STATbits.SPIEN = 1;        // Enable SPI\n\n// Transmit 0x55 and receive byte\nSPI1BUF = 0x55;\nwhile (!SPI1STATbits.SPIRBF);  // Wait for transmission complete\nuint8_t received = SPI1BUF;    // Read received byte\n</code></pre>"},{"location":"chapters/chapter-8/#section-4-i2c-inter-integrated-circuit","title":"Section 4: I2C (Inter-Integrated Circuit)","text":"<p>I2C is a synchronous, serial protocol designed for communication between multiple devices using just two wires:</p> <ul> <li>SCL: Clock line</li> <li>SDA: Data line</li> </ul> <p>One device acts as the master (controls the clock), while others act as slaves.</p>"},{"location":"chapters/chapter-8/#i2c-addressing","title":"I2C Addressing","text":"<p>Each slave on the bus has a 7-bit or 10-bit address. The master begins communication by sending:</p> <ul> <li>A START condition</li> <li>The address of the device it wants to talk to</li> <li>A Read/Write bit</li> <li>A slave responds with an ACK or NACK</li> </ul>"},{"location":"chapters/chapter-8/#typical-use-cases_1","title":"Typical Use Cases","text":"<ul> <li>Reading data from sensors (temp, accelerometer, etc.)</li> <li>Communicating with I2C memory (EEPROMs)</li> <li>Interfacing with real-time clocks or displays</li> </ul> <p>I2C is slower than SPI but allows many devices to share just two pins, saving valuable I/O space.</p>"},{"location":"chapters/chapter-8/#i2c-example-reading-a-byte-from-a-slave-pseudo-code","title":"I2C Example: Reading a Byte from a Slave (Pseudo-code)","text":"<pre><code>I2C1CON = 0;\nI2C1CONbits.SEN = 1;               // START condition\nwhile (I2C1CONbits.SEN);           // Wait for START complete\n\nI2C1TRN = 0b10100000;              // Send slave address (write mode)\nwhile (I2C1STATbits.TBF);          // Wait until byte sent\n\n// Wait for ACK from slave\nwhile (I2C1STATbits.ACKSTAT);      // 0 = ACK, 1 = NACK\n\nI2C1TRN = 0x00;                    // Send register address to read\nwhile (I2C1STATbits.TBF);\n\n// Restart condition to switch to read mode\nI2C1CONbits.RSEN = 1;\nwhile (I2C1CONbits.RSEN);\n\nI2C1TRN = 0b10100001;              // Send slave address (read mode)\nwhile (I2C1STATbits.TBF);\n\n// Wait for ACK, then enable receive\nwhile (I2C1STATbits.ACKSTAT);\nI2C1CONbits.RCEN = 1;              // Enable receive mode\n\nwhile (!I2C1STATbits.RBF);         // Wait for byte\nuint8_t value = I2C1RCV;           // Read received byte\n\nI2C1CONbits.PEN = 1;               // STOP condition\nwhile (I2C1CONbits.PEN);\n</code></pre>"},{"location":"chapters/chapter-8/#notes","title":"Notes","text":"<ul> <li>I2C requires pull-up resistors on both SDA and SCL lines</li> <li>Only one master should control the bus at a time</li> <li>Communication is slower (~100\u2013400kHz typically), but very space-efficient</li> </ul> <p>Next, we\u2019ll look at how to read real-world analog signals using the ADC module.</p>"},{"location":"chapters/chapter-8/#quiz-i2c-communication","title":"Quiz: I2C Communication","text":"<p>Why does I2C require pull-up resistors on the SDA and SCL lines?</p> <ol> <li>To limit power draw from slaves  </li> <li>To allow multiple masters to drive the bus simultaneously  </li> <li>To ensure the lines return to HIGH when not actively driven  </li> <li>To increase the data rate of communication  </li> </ol> Show Answer <p>The correct answer is C.</p> <p>I2C uses open-drain outputs, meaning devices can pull the line LOW but not drive it HIGH. Pull-up resistors ensure the lines default to HIGH when not being pulled down \u2014 allowing multiple devices to safely share the bus.</p>"},{"location":"chapters/chapter-8/#prompt-practice_2","title":"Prompt Practice","text":"<p>Write code to initiate an I2C transmission to a device with address <code>0x68</code>, send a register address <code>0x1C</code>, then restart and request a single byte of data from it.</p> Click to show solution <pre><code>// START condition\nI2C1CONbits.SEN = 1;\nwhile (I2C1CONbits.SEN);\n\n// Send slave address (write)\nI2C1TRN = 0xD0;                    // 0x68 &lt;&lt; 1 | 0 (write)\nwhile (I2C1STATbits.TBF);\nwhile (I2C1STATbits.ACKSTAT);     // Wait for ACK\n\n// Send register address (0x1C)\nI2C1TRN = 0x1C;\nwhile (I2C1STATbits.TBF);\n\n// RESTART condition\nI2C1CONbits.RSEN = 1;\nwhile (I2C1CONbits.RSEN);\n\n// Send slave address (read)\nI2C1TRN = 0xD1;                    // 0x68 &lt;&lt; 1 | 1 (read)\nwhile (I2C1STATbits.TBF);\nwhile (I2C1STATbits.ACKSTAT);\n\n// Enable receive mode\nI2C1CONbits.RCEN = 1;\nwhile (!I2C1STATbits.RBF);        // Wait for byte\n\nuint8_t result = I2C1RCV;         // Read data\n\n// STOP condition\nI2C1CONbits.PEN = 1;\nwhile (I2C1CONbits.PEN);\n</code></pre>"},{"location":"chapters/chapter-8/#section-5-adc-analog-to-digital-converter","title":"Section 5: ADC (Analog-to-Digital Converter)","text":"<p>Analog-to-Digital Conversion (ADC) lets your microcontroller read real-world analog signals \u2014 like voltage, temperature, or light level \u2014 and convert them into digital values it can process.</p>"},{"location":"chapters/chapter-8/#what-does-the-adc-do","title":"What Does the ADC Do?","text":"<p>An ADC samples an input voltage (e.g., 0\u20133.3V) and converts it into a digital number based on:</p> <ul> <li>Resolution (typically 10 bits on PIC24 \u2192 values from 0 to 1023)</li> <li>Reference Voltage (<code>VREF+</code> and <code>VREF-</code>)</li> <li>Sampling time (how long it takes to stabilize before conversion)</li> </ul> <p>For example, if <code>VREF+ = 3.3V</code>, then a reading of 512 \u2248 1.65V.</p>"},{"location":"chapters/chapter-8/#configuring-adc-on-pic24","title":"Configuring ADC on PIC24","text":"<p>Let\u2019s read analog voltage on AN0 (RB0) using the 10-bit ADC module.</p> <pre><code>// Configure RB0/AN0 as analog input\nAD1PCFGbits.PCFG0 = 0;          // Set AN0 as analog\nTRISBbits.TRISB0 = 1;           // Set RB0 as input\n\n// ADC Configuration\nAD1CON = 0;\nAD1CON1bits.FORM = 0;           // Integer output\nAD1CON1bits.SSRC = 7;           // Auto-convert\nAD1CON1bits.ASAM = 1;           // Auto-sample\n\nAD1CON2 = 0;                    // Use MUXA, Vref+ = AVdd, Vref- = AVss\nAD1CON3bits.ADCS = 2;           // ADC clock = Tcy \u00d7 (ADCS + 1)\nAD1CHSbits.CH0SA = 0;           // Select AN0\n\nAD1CON1bits.ADON = 1;           // Turn on ADC\n\n// Read a value\n__delay_ms(1);                  // Allow ADC to stabilize\nwhile (!AD1CON1bits.DONE);      // Wait for conversion\nuint16_t result = ADC1BUF0;     // Read the result\n</code></pre>"},{"location":"chapters/chapter-8/#example-conversions-10-bit-adc","title":"Example Conversions (10-bit ADC)","text":"Input Voltage ADC Value 0.0 V 0 1.65 V 512 3.3 V 1023 <p>ADC values are linear \u2014 you can scale them to voltage using: <code>V = (ADC / 1023.0) \u00d7 VREF</code></p> <p>To better understand how an Analog-to-Digital Converter (ADC) samples continuous signals, use the interactive simulation below.  </p> <p>\ud83d\udc49 Launch the Analog to Digital Simulation</p> <p>Adjust the sampling rate and resolution to see how these parameters affect the digital representation of a smooth analog waveform.</p> <p>Next up: a quick summary of all communication modules and where they\u2019re most useful!</p>"},{"location":"chapters/chapter-8/#section-6-summary-and-use-cases","title":"Section 6: Summary and Use Cases","text":"<p>Here's a quick recap of the communication and peripheral modules covered:</p> Module Use Case Pros Tradeoffs UART PC comms, debugging Simple, widely supported One-to-one only, no addressing SPI Sensors, memory, displays Fast, full-duplex Needs 4 wires, no native addressing I2C Multiple devices, clocks, EEPROMs Two wires, device addressing Slower, requires pull-ups ADC Sensors, analog input Converts real-world signals Needs stable voltage, limited speed <p>Choose the right tool for the job \u2014 and test with real hardware whenever possible!</p>"},{"location":"chapters/chapter-8/#quiz-understanding-adc","title":"Quiz: Understanding ADC","text":"<p>You\u2019re using a 10-bit ADC with a reference voltage of 3.3V. What voltage does a digital reading of <code>682</code> most closely represent?</p> <ol> <li>1.1 V  </li> <li>2.2 V  </li> <li>3.0 V  </li> <li>3.3 V  </li> </ol> Show Answer <p>The correct answer is B (2.2 V).</p> <p>Use the conversion formula: <code>V = (ADC / 1023) \u00d7 VREF</code> \u2192 <code>(682 / 1023) \u00d7 3.3V \u2248 2.2V</code></p>"},{"location":"chapters/chapter-8/#prompt-practice_3","title":"Prompt Practice","text":"<p>Write code to configure the ADC to read from AN2 (RB2) and store the result in a variable.</p> Click to show solution <pre><code>// Configure AN2/RB2 as analog input\nAD1PCFGbits.PCFG2 = 0;           // AN2 = analog\nTRISBbits.TRISB2 = 1;            // RB2 as input\n\n// Basic ADC config\nAD1CON1bits.FORM = 0;            // Integer format\nAD1CON1bits.SSRC = 7;            // Auto-convert\nAD1CON1bits.ASAM = 1;            // Auto-sample\n\nAD1CON2 = 0;\nAD1CON3bits.ADCS = 2;\nAD1CHSbits.CH0SA = 2;            // Use AN2\n\nAD1CON1bits.ADON = 1;            // Enable ADC\n\n// Read the ADC value\n__delay_ms(1);\nwhile (!AD1CON1bits.DONE);\nuint16_t adcValue = ADC1BUF0;\n</code></pre> <p>That\u2019s the end of Chapter 8! </p>"},{"location":"sims/","title":"MicroSim Gallery","text":"<p>Explore the interactive MicroSimulations designed to reinforce key concepts:</p> <ul> <li>Stack Visualizer (Function Calls and Returns)</li> <li>Timer Interrupt Simulator (LED Blink)</li> <li>PWM Waveform Generator</li> <li>Input Capture Simulation</li> <li>Live ADC Value Visualization</li> <li>Basic Digital I/O (TRIS, LAT, AD1PCFG)</li> <li>Register Operation Simulator (MOV, ADD, SUB)</li> <li>Branch Loop Simulator</li> <li>Serial Communication Overview (UART, SPI, I2C)</li> </ul> <p>Enjoy exploring these interactive learning tools!</p>"},{"location":"sims/acd-sim/","title":"ADC Sampling Simulator","text":"<p>This MicroSim demonstrates how an Analog-to-Digital Converter (ADC) samples and quantizes a continuous analog signal.</p> <ul> <li>Adjust the sampling rate to control how often samples are taken</li> <li>Adjust the resolution (number of bits) to see how quantization affects the signal</li> <li>Observe how a higher sampling rate and resolution produce a smoother digital representation</li> </ul> <p>\ud83d\udc49 Launch the ADC Sampling Simulation</p>"},{"location":"sims/ch1-pin-config-sim/","title":"Chapter 1 MicroSim: Digital Output Pin Configuration","text":"<p>This simulation demonstrates how the following PIC24 configuration registers affect digital output behavior:</p> <ul> <li>TRISx: Determines pin direction (input/output)</li> <li>AD1PCFG: Configures the pin for digital or analog use</li> <li>LATx: Controls the output level (high/low) when configured as output</li> </ul> <p>\ud83d\udc49 Launch the Pin Config Simulation</p> <p>Use the interface to toggle TRIS, AD1PCFG, and LAT settings, and observe the resulting pin state.</p>"},{"location":"sims/ch2-register-sim/","title":"Chapter 2 MicroSim: Register Instruction Simulator (v2)","text":"<p>This interactive simulation lets you practice basic PIC24 assembly operations by manipulating working registers (<code>W0</code>\u2013<code>W5</code>) in real time.</p> <p>You can perform:</p> <ul> <li>Moving values between registers or from literals</li> <li>Adding and subtracting using either 2 operands or 3 operands</li> <li>Clearing registers</li> </ul> <p>\ud83d\udc49 Launch the Register Instruction Simulator</p>"},{"location":"sims/ch2-register-sim/#supported-instructions","title":"Supported Instructions:","text":"Instruction Meaning <code>MOV #literal, Wn</code> Move immediate value into register <code>MOV Wm, Wn</code> Copy value from one register to another <code>ADD Wm, Wn</code> Add Wm to Wn, store in Wn <code>ADD #literal, Wn</code> Add literal to Wn <code>ADD Wm, Wn, Wd</code> Add Wm + Wn, store result in Wd <code>SUB Wm, Wn</code> Subtract Wm from Wn, store in Wn <code>SUB Wm, Wn, Wd</code> Subtract Wm from Wn, store in Wd <code>CLR Wn</code> Clear (zero out) Wn"},{"location":"sims/ch2-register-sim/#example-instructions","title":"Example Instructions:","text":"<pre><code>MOV     #10, W0       ; Load literal 10 into W0\nMOV     W0, W1        ; Copy W0 into W1\nADD     W1, W2        ; Add W1 into W2\nADD     W0, W1, W3    ; W3 = W0 + W1\nSUB     W1, W2        ; Subtract W1 from W2 (W2 = W2 - W1)\nSUB     W1, W2, W4    ; W4 = W2 - W1\nCLR     W3            ; Clear W3\n</code></pre>"},{"location":"sims/ch3-branch-loop-sim/","title":"Chapter 3 MicroSim: Loop Flow Visualizer","text":"<p>This MicroSim lets you visually trace the behavior of a loop written in PIC24 assembly using instructions like <code>DEC</code>, <code>CP</code>, and <code>BNE</code>.</p> <p>You\u2019ll see:</p> <ul> <li>Each instruction executed step-by-step</li> <li>Branches (<code>BNE</code>) visually jumping back to labeled code</li> <li>Final program continuation indicated with <code>; ... more code</code></li> <li>Live W0 value and total loop iterations</li> </ul> <p>\ud83d\udc49 Launch the Branching and Loop Simulator</p>"},{"location":"sims/ch3-branch-loop-sim/#code-simulated","title":"Code Simulated:","text":"<pre><code>MOV #5, W0      ; Load 5 into W0\nLOOP:\nDEC W0          ; Decrement W0\nCP W0, #0       ; Compare to 0\nBNE LOOP        ; If W0 != 0, loop back\n; ... more code\n</code></pre>"},{"location":"sims/ch8-serial-comm-overview/","title":"Chapter 8 MicroSim: Serial Communication Overview","text":"<p>This simulation provides a quick interactive overview of three important serial communication protocols used with microcontrollers:</p> <ul> <li>UART (Universal Asynchronous Receiver/Transmitter)</li> <li>SPI (Serial Peripheral Interface)</li> <li>I2C (Inter-Integrated Circuit)</li> </ul> <p>\ud83d\udc49 Launch the Serial Communication Overview MicroSim</p>"},{"location":"sims/ch8-serial-comm-overview/#what-you-can-do","title":"\ud83d\udcda What You Can Do:","text":"<ul> <li>Click the UART, SPI, or I2C tabs</li> <li>See basic visual representations of how data flows</li> <li>Understand key concepts like clocking, addressing, and handshaking</li> <li>Compare the differences between asynchronous and synchronous protocols</li> </ul> <p>This is a great way to visually grasp the big picture of serial communications!</p>"},{"location":"sims/ic_sim/","title":"Input Capture Simulator","text":"<p>This MicroSim demonstrates how the Input Capture (IC) module records timer values on an event.</p> <ul> <li>Press Start Pulse to generate a simulated pulse</li> <li>Adjust the pulse duration using the slider</li> <li>View the captured timer value and pulse width</li> </ul> <p>\ud83d\udc49 Launch the Input Capture Simulation</p>"},{"location":"sims/pwm-sim/","title":"PWM Visualizer","text":"<p>This MicroSim demonstrates how Pulse Width Modulation (PWM) controls LED brightness.</p> <ul> <li>Use the slider to change the duty cycle</li> <li>Observe how the waveform and LED brightness respond</li> </ul> <p>\ud83d\udc49 Launch the PWM Simulation</p>"},{"location":"sims/stack-tray-sim/","title":"Stack Tray Simulation","text":"<p>This simulation uses a cafeteria tray analogy to demonstrate how the call stack behaves in a typical program.</p> <p>\ud83d\udc49 Launch the Stack Tray Simulation</p> <p>Features:</p> <ul> <li>CALL pushes a tray onto the stack (like a function call)</li> <li>RETURN pops a tray off the stack (like returning from a function)</li> <li>RESET clears the stack entirely</li> <li>Stack grows from bottom to top (LIFO: Last In, First Out)</li> </ul> <p>Each tray represents a function call, helping you visually understand how nested function calls and returns interact with memory.</p>"},{"location":"sims/timer-isr-sim/","title":"Timer ISR Simulation","text":"<p>This enhanced simulation demonstrates how a timer (TMR1) triggers an interrupt when it reaches a match value (PR1).</p> <p>\ud83d\udc49 Click here to launch the Timer ISR Simulation</p> <p>New Feature: - A traffic-light style visual indicator flashes red \u2192 yellow \u2192 green when the interrupt fires.</p> <p>Features:</p> <ul> <li>Adjustable PR1 (interrupt match value)</li> <li>Timer starts incrementing when you click \"Start\"</li> <li>When TMR1 matches PR1, an interrupt is triggered and the timer resets</li> <li>Press \"Stop\" or \"Reset\" at any time</li> </ul>"}]}